#pragma config(Sensor, in1,    ballDetector,   sensorLineFollower)
#pragma config(Sensor, in8,    anglerPoti,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,           driveLY,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterY,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           angler,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRY,       tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define MOTOR_SENSOR_LOGS 1

unsigned char _hogLevel = 0;
void tHog()
{
	if (!_hogLevel++)
		hogCPU();
}

void tRelease()
{
	if (_hogLevel && !--_hogLevel)
		releaseCPU();
}

//#include "../src/task.h"
#include "../src/motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "utilities.h"
#include "auto.h"
#include "cycle.h"

// Year-independent libraries (source)
//#include "task.c"
#include "../src/motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "utilities.c"
#include "cycle.c"

#define BTN_SHOOT Btn5U
#define BTN_INTAKE_UP Btn6U
#define BTN_INTAKE_DOWN Btn6D

#define JOY_ANGLER Ch2
#define BTN_ANGLER_TEST Btn5D

#define JOY_THROTTLE Ch3
#define JOY_TURN Ch4

//#define LIM_TO_VAL(input, val) (abs(input) > (val) ? (val) * sgn(input) : (input))
#define RESET_OFFSET 45
#define SHOOTER_GEAR_RATIO 1.0
#define SHOOTER_RELOAD_VAL ((360.0*SHOOTER_GEAR_RATIO) + RESET_OFFSET)
#define SHOOTER_RELOAD_HOLD 0//11
#define SHOOTER_RELOAD_POS (145 + RESET_OFFSET)

#define BD_UNPLUGGED (gSensor[ballDetector].value >= 246 && gSensor[ballDetector].value <= 252)

#define BALL_DETECTED (gSensor[ballDetector].value < 1000 && (!BD_UNPLUGGED))


unsigned long curTimeS, timeOutS, accelTimeS;
int moveAmntS;

#define WHILE_SHOOTER_MOVING(moveAmt, accelTime, TO, condition) \
curTimeS = npgmtime; \
timeOutS = TO + curTimeS; \
accelTimeS = curTimeS + accelTime; \
moveAmntS = gSensor[shooterEnc].value + moveAmt; \
while (moving(moveAmntS, accelTimeS, timeOutS, gSensor[shooterEnc]) && (condition))


bool moving (int moveAmnt, unsigned long accelTime, unsigned long timeOut, sSensor& sen)
{
	if ((npgmTime < accelTime || sen.value > moveAmnt) && npgmTime < timeOut) return true;
	else if (npgmTime >= timeOut)
	{
		writeDebugStreamLine("%d TimedOut past %d", npgmtime, timeOut);
		return false;
	}
	else
	{
		writeDebugStreamLine("%d TimedOut: Hasn't moved %d w/in %d ms. At%d", npgmtime, moveAmnt, accelTime, sen.value);
		//if (sen == gSensor[shooterEnc]) killShooter();
		return false;
	}
}

typedef enum _tShooterState
{
	shooterIdle,
	shooterBreak,
	shooterReload,
	shooterHold,
	shooterShoot,
	shooterReset
} tShooterState;

void setShooter(word val)
{
	gMotor[shooter].power = gMotor[shooterY].power = LIM_TO_VAL(val, 127);
}
tShooterState gShooterState;
tShooterState gShooterStateLst;
unsigned long gShooterStateTime; //Stores the time the shooter state is changed
int gShooterStateSen;

void setShooterState (tShooterState state)
{
	if (state != gShooterState)
	{
		gShooterStateLst = gShooterState;
		gShooterState = state;

		gShooterStateTime = npgmtime;
		gShooterStateSen = gSensor[shooterEnc].value;
	}
}

int shooterShotCount = 0;
task shooterStateSet()
{
	gShooterState = shooterIdle;

	float shooterBreakOffset = 6;

	resetQuadratureEncoder(shooterEnc);

	sCycleData cycle;
	initCycle(cycle, 10, "shooter");
	while (true)
	{
		switch (gShooterState)
		{
			case shooterIdle:
				setShooter(0);
				break;
			case shooterBreak:
				setShooter(-90);
				unsigned long timerStart = npgmtime;
				while( (npgmTime-timerStart) < 100 ) sleep(10);
				setShooter(0);
				PlayTone(300, 50);

				setShooterState(shooterIdle);
				break;
			case shooterReload:
				setShooter(127);
				int target = shooterShotCount * SHOOTER_RELOAD_VAL;

				WHILE_SHOOTER_MOVING(10, 100, 400, gSensor[shooterEnc].value < (target + SHOOTER_RELOAD_POS))
				{
					sleep(10);
				}

				writeDebugStreamLine("%d Reloaded to %d", npgmtime, gSensor[shooterEnc].value);

				setShooterState(shooterHold);
				break;
			case shooterHold:
				setShooter(SHOOTER_RELOAD_HOLD);
				break;
			case shooterShoot:
				unsigned long shotStartTime = npgmtime;
				shooterShotCount++;
				target = shooterShotCount * SHOOTER_RELOAD_VAL;
				setShooter(127);
				//writeDebugStreamLine("Fired shot #%d at %d, Tgt: %d, Enc: %d, Err: %d", shooterShotCount, nPgmTime, gSensor[shooterEnc].value, target, target - gSensor[shooterEnc].value);
				writeDebugStreamLine("%d Start shot %d: Time: %d Pos:%d ", npgmtime, shooterShotCount, npgmtime-shotStartTime, gSensor[shooterEnc].value);

				bool shotTargReached = ( gSensor[shooterEnc].value > (target-shooterBreakOffset) );

				WHILE_SHOOTER_MOVING(10, 150, 700, !shotTargReached && (gSensor[shooterEnc].value < (target-85) || gSensor[shooterEnc].value > (target-15) || BALL_DETECTED))
				{
					//writeDEbugStreamLine("Ball? %d", BALL_DETECTED);
					shotTargReached = ( gSensor[shooterEnc].value > (target-shooterBreakOffset) );

					unsigned long timeElpsd = npgmtime-shotStartTime;

					sleep(10);
				}
				if (!shotTargReached)
				{
					writeDebugStreamLine("%d Ball gone: Val:%d, Time: %d Pos:%d, Targ:%d ", npgmtime, gSensor[ballDetector].value, npgmtime-shotStartTime, gSensor[shooterEnc].value, target);
					setShooter(-90);
					sleep(80);
					setShooter(0);
					shooterShotCount--;
					while (gSensor[shooterEnc].value > (target + SHOOTER_RELOAD_POS)) sleep(10);
					setShooter(SHOOTER_RELOAD_HOLD);
					PlayTone(300, 50);
				}
				else
				{
					writeDebugStreamLine("%d Start break: Time: %d Pos:%d ", npgmtime, npgmtime-shotStartTime, gSensor[shooterEnc].value);
					setShooter(-22);
					unsigned long startBreakTime = npgmtime;
					while ((npgmtime-startBreakTime) < 80)
					{
						//writeDebugStreamLine("%d Break", npgmtime);
						if (gSensor[ballDetector].value > 2000)
						{
							//writeDebugStreamLine("	%d Ball hit: Time: %d", npgmtime, npgmtime-shotStartTime);
						}
						sleep(10);
					}
					//sleep(80);
					//writeDebugStreamLine("Break done at %d, Enc: %d", nPgmTime, gSensor[shooterEnc].value);
					setShooter(0);

					writeDebugStreamLine("%d Shoot Trigger False - shot end", npgmtime);
				}

				setShooterState(shooterIdle);
				break;

			case shooterReset:
				setShooter(-18);
				float vel = -1;
				float lstVel = -1;
				sleep(300);
				do
				{
					velocityCheck(shooterEnc);
					vel = gSensor[shooterEnc].velocity;
					lstVel = gSensor[shooterEnc].lstVelocity;
					//writeDebugStreamLine("%d Vel:%f, LstVel:%f", npgmtime, vel, lstVel);
					sleep(10);
				} while(vel < -0.001 || lstVel < -0.001);
				setShooter(0);
				sleep(150);
				writeDEbugStreamLine("%d Reset Shooter from %d", npgmtime, gSensor[shooterEnc].value);
				PlayTone(300, 50);
				resetQuadratureEncoder(shooterEnc);
				shooterShotCount = 0;
				sleep(50);

				setShooterState(shooterIdle);
				break;
		}
		endCycle(cycle);
	}
}

void shooterSafety()
{
	if (gShooterState == shooterIdle && gShooterStateTime > 500)
		writeDebugStreamLine(" %d Shooter timeout (Idle)", npgmtime);
}

task updateVals()
{
	//gMotor[shooter].datalog = 1;
	//gMotor[shooterY].datalog = 2;
	//writeDebugStreamLine("%d Start update", npgmtime);
	sCycleData cycle;
	initCycle(cycle, 10, "UpdateVals");
	unsigned long startTime = npgmtime;
	while (true)
	{
		startTime = npgmtime;
		tHog();
		updateJoysticks();
		updateMotors();
		updateSensorInputs();
		updateSensorOutputs();
		////writeDebugStreamLine("Update-shooter:%d", gSensor[shooterEnc].value);

		shooterSafety();

		tRelease();
		endCycle(cycle);
		//if ((npgmTime - startTime) > 10) writeDebugStreamLine("   %d ERROR Update Vals took %dms", npgmtime, (npgmTime-startTime));
	}
}


task main()
{
	clearDebugStream();
	setupSensors();
	setupMotors();
	setupJoysticks();

	clearDebugStream();
	int nBatteryLevel = nImmediateBatteryLevel;
	writeDebugStream("%d Battery: %d", nPgmTime, nBatteryLevel);

	//Setup Joystics
	enableJoystick(BTN_SHOOT);
	enableJoystick(BTN_ANGLER_TEST);
	enableJoystick(JOY_ANGLER);
	enableJoystick(JOY_THROTTLE);
	enableJoystick(JOY_TURN);

	resetQuadratureEncoder(ballDetector);

	startTask(updateVals);
	startTask(shooterStateSet);
	while (true) sleep(10);
	stopTask(updateVals);
	stopTask(shooterStateSet);
}
