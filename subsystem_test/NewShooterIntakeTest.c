#pragma config(Sensor, in1,    ballDetector,   sensorLineFollower)
#pragma config(Sensor, in8,    anglerPoti,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,           driveLY,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterY,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           angler,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRY,       tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define MOTOR_SENSOR_LOGS 1

unsigned char _hogLevel = 0;
void tHog()
{
	if (!_hogLevel++)
		hogCPU();
}

void tRelease()
{
	if (_hogLevel && !--_hogLevel)
		releaseCPU();
}

//#include "../src/task.h"
#include "../src/motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "utilities.h"
#include "auto.h"
#include "cycle.h"

// Year-independent libraries (source)
//#include "task.c"
#include "../src/motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "utilities.c"
#include "cycle.c"

#define BTN_SHOOT Btn5U
#define BTN_INTAKE_UP Btn6U
#define BTN_INTAKE_DOWN Btn6D

#define JOY_ANGLER Ch2
#define BTN_ANGLER_TEST Btn5D

#define JOY_THROTTLE Ch3
#define JOY_TURN Ch4

//#define LIM_TO_VAL(input, val) (abs(input) > (val) ? (val) * sgn(input) : (input))
#define RESET_OFFSET 45
#define SHOOTER_GEAR_RATIO 1.0
#define SHOOTER_RELOAD_VAL ((360.0*SHOOTER_GEAR_RATIO) + RESET_OFFSET)
#define SHOOTER_RELOAD_HOLD 0//11
#define SHOOTER_RELOAD_POS (145 + RESET_OFFSET)

#define BD_UNPLUGGED (gSensor[ballDetector].value >= 246 && gSensor[ballDetector].value <= 252)

#define BALL_DETECTED (gSensor[ballDetector].value < 1000 && (!BD_UNPLUGGED))

void killShooter();

unsigned long curTimeS, timeOutS, accelTimeS;
int moveAmntS;

#define WHILE_SHOOTER_MOVING(moveAmt, accelTime, TO, condition) \
curTimeS = nPgmTime; \
timeOutS = TO + curTimeS; \
accelTimeS = curTimeS + accelTime; \
moveAmntS = gSensor[shooterEnc].value + moveAmt; \
while (moving(moveAmntS, accelTimeS, timeOutS, gSensor[shooterEnc]) && (condition))


bool moving (int moveAmnt, unsigned long accelTime, unsigned long timeOut, sSensor& sen)
{
	if ((nPgmTime < accelTime || sen.value > moveAmnt) && nPgmTime < timeOut) return true;
	else if (nPgmTime >= timeOut)
	{
		writeDebugStreamLine("%d TimedOut past %d", nPgmTime, timeOut);
		return false;
	}
	else
	{
		writeDebugStreamLine("%d TimedOut: Hasn't moved %d w/in %d ms. At%d", nPgmTime, moveAmnt, accelTime, sen.value);
		//if (sen == gSensor[shooterEnc]) killShooter();
		return false;
	}
}

int gShooterPow;
/*
task printEnc()
{
	while (true)
	{
		datalogDataGroupStart();
		datalogAddValue(1, gSensor[shooterEnc].value);
		datalogAddValue(2, gShooterPow);
		datalogDataGroupEnd();

		sleep(10);
	}
}
*/
typedef enum _tSpinDir
{
	spinStop,
	spinUp,
	spinDown
}tSpinDir;

task intakeTask()
{
	bool buttonUP, lstButtonUp, buttonDown, lstButtonDown, buttonStop, lstButtonStop;
	tSpinDir spinDir = spinStop;

	while (true)
	{
		//buttonUp = vexRT[BTN_INTAKE_UP];
		//buttonDown = vexRT[BTN_INTAKE_DOWN];

		////writeDebugStreamLine("spindir=%d", spinDir);
		if (RISING(BTN_INTAKE_UP))
		{
			if (spinDir != spinStop)
				spinDir = spinStop;
			else
				spinDir = spinUp;
		}
		if (RISING(BTN_INTAKE_UP))
		{
			if (spinDir != spinStop)
				spinDir = spinStop;
			else
				spinDir = spinDown;
		}

		switch (spinDir)
		{
			case spinStop:
				////writeDebugStreamLine("%d Spin stop", nPgmTime);
				gMotor[intake].power = 0;
				break;
			case spinUp:
				////writeDebugStreamLine("%d Spin up", nPgmTime);
				gMotor[intake].power = 127;
				break;
			case spinDown:
				////writeDebugStreamLine("%d Spin down", nPgmTime);
				gMotor[intake].power = -127;
				break;
		}

		//lstButtonUp = buttonUp;
		//lstButtonDown = buttonDown;
		sleep(50);
	}
}

int shooterShotCount;

void setShooter(word val)
{
	//gMotor[shooter].power = gMotor[shooterB].power = LIM_TO_VAL(val, 127);
	gShooterPow = LIM_TO_VAL(val, 127);
	gMotor[shooter].power = gMotor[shooterY].power = LIM_TO_VAL(val, 127);
}

void resetShooter()
{
				setShooter(-18);
				float vel = -1;
				float lstVel = -1;
				sleep(300);
				do
				{
					velocityCheck(shooterEnc);
					vel = gSensor[shooterEnc].velocity;
					lstVel = gSensor[shooterEnc].lstVelocity;
					//writeDebugStreamLine("%d Vel:%f, LstVel:%f", nPgmTime, vel, lstVel);
					sleep(10);
				} while(vel < -0.001 || lstVel < -0.001);
				setShooter(0);
				sleep(150);
				writeDebugStreamLine("%d Reset Shooter from %d", nPgmTime, gSensor[shooterEnc].value);
				playTone(300, 50);
				resetQuadratureEncoder(shooterEnc);
				shooterShotCount = 0;
				sleep(50);
}

void reloadShooter()
{
	setShooter(127);
	//writeDebugStreamLine("Setup shot #%d encoder start= %d", shooterShotCount,gSensor[shooterEnc].value);
	int target = shooterShotCount * SHOOTER_RELOAD_VAL;

	WHILE_SHOOTER_MOVING(10, 100, 400, gSensor[shooterEnc].value < (target + SHOOTER_RELOAD_POS))
	{
		sleep(10);
		//writeDebugStreamLine("Enc: %d", gSensor[shooterEnc].value);
	}

	writeDebugStreamLine("%d Reloaded to %d", nPgmTime, gSensor[shooterEnc].value);
	setShooter(SHOOTER_RELOAD_HOLD);
}

task shooterMonitor()
{
	while (true)
	{
		datalogDataGroupStart();
		datalogAddValue(1, gSensor[shooterEnc].value);
		datalogAddValue(2, gSensor[ballDetector].value);
		datalogAddValue(3, gMotor[shooter].curPower);
		datalogAddValue(4, gMotor[shooterY].curPower);
		datalogDataGroupEnd();
		sleep(10);
	}
}
bool shootTrigger;
task shooterTask()
{
	bool secondShot = false;
	shooterShotCount = 0;
	resetQuadratureEncoder(shooterEnc);

	//writeDebugStreamLine("Start");
	const float breakKp = -25.0;
	float shooterBreakOffset = 6;

	bool shotTargReached = false;

	bool cancelledPrint = false;
	shootTrigger = false;

	sleep(100);
	resetShooter();
	reloadShooter();

	while (true)
	{

		if (shootTrigger || vexRT[BTN_SHOOT])//RISING(BTN_SHOOT) )
		{
			writeDebugStreamLine("%d Shot Triggered", nPgmTime);

			int target = shooterShotCount * SHOOTER_RELOAD_VAL;
			if (gSensor[shooterEnc].value < (target+SHOOTER_RELOAD_POS)) //Should only get triggered when shooterShotCount == 0
			{
				reloadShooter();
				while (!vexRT[BTN_SHOOT] && !shootTrigger) sleep(10);
			}

			if(gSensor[ballDetector].value > 1000 && !secondShot)
			{
				if (!cancelledPrint)
				{
					//writeDebugStreamLine("%d No Ball - Shot Cancelled");
					cancelledPrint = true;
				}
			}
			else if(BD_UNPLUGGED)
			{
				if (!cancelledPrint)
				{
					writeDebugStreamLine("%d Ball Detector Unplugged - Shot Cancelled");
					cancelledPrint = true;
				}
			}
			else
			{
				cancelledPrint = false;
				unsigned long shotStartTime = nPgmTime;
				shooterShotCount++;
				target = shooterShotCount * SHOOTER_RELOAD_VAL;
				setShooter(127);
				//writeDebugStreamLine("Fired shot #%d at %d, Tgt: %d, Enc: %d, Err: %d", shooterShotCount, nPgmTime, gSensor[shooterEnc].value, target, target - gSensor[shooterEnc].value);
				writeDebugStreamLine("%d Start shot %d: Time: %d Pos:%d ", nPgmTime, shooterShotCount, nPgmTime-shotStartTime, gSensor[shooterEnc].value);

				shotTargReached = ( gSensor[shooterEnc].value > (target-shooterBreakOffset) );

				WHILE_SHOOTER_MOVING(10, 150, 700, !shotTargReached && (gSensor[shooterEnc].value < (target-85) || gSensor[shooterEnc].value > (target-15) || BALL_DETECTED))
				{
					//writeDebugStreamLine("Ball? %d", BALL_DETECTED);
					shotTargReached = ( gSensor[shooterEnc].value > (target-shooterBreakOffset) );

					unsigned long timeElpsd = nPgmTime-shotStartTime;

					sleep(10);
				}
				if (!shotTargReached)
				{
					writeDebugStreamLine("%d Ball gone: Val:%d, Time: %d Pos:%d, Targ:%d ", nPgmTime, gSensor[ballDetector].value, nPgmTime-shotStartTime, gSensor[shooterEnc].value, target);
					setShooter(-90);
					sleep(80);
					setShooter(0);
					shooterShotCount--;
					while (gSensor[shooterEnc].value > (target + SHOOTER_RELOAD_POS)) sleep(10);
					setShooter(SHOOTER_RELOAD_HOLD);
					playTone(300, 50);
					shootTrigger = false;
				}
				else
				{
					writeDebugStreamLine("%d Start break: Time: %d Pos:%d ", nPgmTime, nPgmTime-shotStartTime, gSensor[shooterEnc].value);
					setShooter(-22);
					unsigned long startBreakTime = nPgmTime;
					while ((nPgmTime-startBreakTime) < 80)
					{
						//writeDebugStreamLine("%d Break", nPgmTime);
						if (gSensor[ballDetector].value > 2000)
						{
							//writeDebugStreamLine("	%d Ball hit: Time: %d", nPgmTime, nPgmTime-shotStartTime);
						}
						sleep(10);
					}
					//sleep(80);
					//writeDebugStreamLine("Break done at %d, Enc: %d", nPgmTime, gSensor[shooterEnc].value);
					setShooter(0);
					//writeDebugStreamLine("Hold done at %d, Tgt: %d, Enc: %d, Err: %d", nPgmTime, target, gSensor[shooterEnc].value, target - gSensor[shooterEnc].value);
					////writeDebugStreamLine("%dStart break %d, %d", nPgmTime, shooterShotCount, gSensor[shooterEnc].value);
					//sleep(50);
					shootTrigger = false;
					writeDebugStreamLine("%d Shoot Trigger False - shot end", nPgmTime);
					reloadShooter();
					//writeDebugStreamLine("%d Total Shot Time:%d", nPgmTime, nPgmTime-shotStartTime);

					if (!secondShot && vexRT[BTN_SHOOT]) secondShot = true;
					else if (secondShot) secondShot = false;
				}
			}
		}

		sleep(10);
	}
	//stopTask(printEnc);
}

#define ANGLER_HOLD_POWER 9

void setAngler(word val)
{
	gMotor[angler].power = LIM_TO_VAL(val, 127);
}

void moveAnglerSimple(int target)
{
	float percentFull = 0.85;
	float percentDecel = 0.95;
	int decelSpeed = 68;
	bool BtnAngleUp, BtnAngleUpLst;

	setAngler(127);
	while(SensorValue[anglerPoti]<(percentFull*target))
	{
		sleep(10);
	}

	while(SensorValue[anglerPoti]<(percentDecel*target))
	{
		int error = target-SensorValue[anglerPoti];
		setAngler(error*0.3);
		sleep(10);
	}

	setAngler(-20);
	while(SensorValue[anglerPoti]<target)
	{
		sleep(10);
	}

	sleep(50);
	setAngler(15);
	//sleep(300);
	//writeDebugStreamLine("Intake Podi Value: %d",SensorValue[anglerPoti]);
}

void moveAngler(int target)
{
	float distance = target - gSensor[anglerPoti].value;
	float lstDistance = distance;
			float kP = (distance < 0)? 0.08 : 0.12;
			float kD = (distance < 0)? 0.5 : 0.2;
			int bias = ANGLER_HOLD_POWER + 2;
			unsigned long startTime = nPgmTime;
			do
			{
				distance = target - gSensor[anglerPoti].value;
				int der = kD * (distance-lstDistance);
				int power = distance * kP + bias + der;
				setAngler(power);
				velocityCheck(anglerPoti);
				//writeDebugStreamLine("%d Vel:%f, Der: %f, Angler Power: %d, Loc: %d, Targ: %d", nPgmTime, gSensor[anglerPoti].velocity, der, power, gSensor[anglerPoti].value, target);

				lstDistance = distance;
				sleep(10);
			} while (abs(distance) > 50 && (nPgmTime-startTime < 600));
			startTime = nPgmTime;
			do
			{
				velocityCheck(anglerPoti);
				setAngler(gSensor[anglerPoti].velocity * (distance<0? -13 : -7));
			} while(abs(gSensor[anglerPoti].velocity) > 0.001 && (nPgmTime-startTime) < 80);
			setAngler(ANGLER_HOLD_POWER);

			writeDebugStreamLine("%d Done angle Vel:%f, Loc: %d, Targ: %d", nPgmTime, gSensor[anglerPoti].velocity, gSensor[anglerPoti].value, target);
}

void moveAnglerP(int target)
{
	float distance = target - gSensor[anglerPoti].value;
	float lstDistance = distance;

	float kP = (distance > 1000)? 0.07 : 0.03;
	unsigned long startTime = nPgmTime;

	float vel;
	int velLowCount = 0;

	sCycleData anglerMove;
	initCycle(anglerMove, 10, "anglerMove");
	do
	{
		distance = target - gSensor[anglerPoti].value;
		float power = distance * kP + ANGLER_HOLD_POWER;
		setAngler(power);

		velocityCheck(anglerPoti);

		vel = gSensor[anglerPoti].velocity;
		if (abs(vel) < 0.1) velLowCount++;
		else velLowCount = 0;
		writeDebugStreamLine("%d Angler D: %d, Pow: %f, Vel: %f, Vlc: %d", nPgmTime, distance, power, vel, velLowCount);

		endCycle(anglerMove);
	} while (velLowCount < 10 && (nPgmTime - startTime) < 1500);

	writeDebugStreamLine("%d Done angler move to %d", nPgmTime, gSensor[anglerPoti].value);

	setAngler(ANGLER_HOLD_POWER);
}

task intakeAnglerTask()
{
	moveAnglerP(1250);
	writeDebugStreamLine("%d, Pos:%d", nPgmTime, gSensor[anglerPoti].value);
	setAngler(-30);
	sleep(400);

	while (true)
	{
		////writeDebugStreamLine("%d, Angler: %d", nPgmTime, gSensor[anglerPoti].value);
		if (RISING(BTN_ANGLER_TEST))
		{
			moveAnglerP(1250);
			sleep(2000);
			setAngler(-70);
			while (gSensor[anglerPoti].value > 250) sleep(10);
			setAngler(ANGLER_HOLD_POWER);

			//writeDebugStreamLine("%d Start Double Shot", nPgmTime);
				/*
			shootTrigger = true;
			moveAnglerP(1250);
			while (shootTrigger == true) sleep(10);
			unsigned long startTime = nPgmTime;
			//writeDebugStreamLine("%d Done first shot", nPgmTime);
			shootTrigger = true;
			moveAnglerP(1030);
			while (shootTrigger == true) sleep(10);
				*/
			//writeDebugStreamLine("%d Double Shot took %d", nPgmTime, nPgmTime-startTime);
		}
		else if (abs(gJoy[JOY_ANGLER].cur) > 10 && (gSensor[anglerPoti].value > 510 && gSensor[anglerPoti].value < 3037))
		{
			setAngler(gJoy[JOY_ANGLER].cur);
		}
		else
		{
			setAngler(0);
			//setAngler(ANGLER_HOLD_POWER);
			//setShooter(127);
		}
		sleep(10);
	}
}

void setDrive(word l, word r)
{
	gMotor[driveL].power = gMotor[driveLY].power = LIM_TO_VAL(l, 127);
	gMotor[driveR].power = gMotor[driveRY].power = LIM_TO_VAL(r, 127);
}

task driveTask()
{
	int THROTTLE_DZ = 10;
	int TURN_DZ = 10;
	while (true)
	{
		int throttle = (abs(gJoy[JOY_THROTTLE].cur) < THROTTLE_DZ)? 0 : gJoy[JOY_THROTTLE].cur;
		int turn = (abs(gJoy[JOY_TURN].cur) < TURN_DZ)? 0 : gJoy[JOY_TURN].cur;
		setDrive(throttle + turn, throttle - turn);
		sleep(10);
	}
}
task updateVals()
{
	//gMotor[shooter].datalog = 1;
	//gMotor[shooterY].datalog = 2;
	//writeDebugStreamLine("%d Start update", nPgmTime);
	sCycleData cycle;
	initCycle(cycle, 10, "UpdateVals");
	unsigned long startTime = nPgmTime;
	while (true)
	{
		startTime = nPgmTime;
		tHog();
		updateJoysticks();
		updateMotors();
		updateSensorInputs();
		updateSensorOutputs();
		////writeDebugStreamLine("Update-shooter:%d", gSensor[shooterEnc].value);
		tRelease();
		endCycle(cycle);
	}
}

void killShooter()
{
	writeDebugStreamLine("%d KILL SHOOTER", nPgmTime);
	setShooter(0);
	stopTask(shooterTask);
	setShooter(0);
	stopTask(updateVals);
	//sleep(200);
	motor[shooter] = motor[shooterY] = -90;
	sleep(70);
	motor[shooter] = motor[shooterY] = 0;
}

task shooterSafety
{
	int highValTimer = 0;
	const int highValLimit = 500;
	bool killed = false;
	while (true)
	{
		//if (abs(Motor[shooter]) >= 100 || abs(Motor[shooterY]) >= 100)
		if ((abs(gMotor[shooter].curPower) >= 100 || abs(gMotor[shooterY].curPower) >= 100) && highValTimer == 0)
		{
			writeDebugStreamLine("%d New highVal set %d", nPgmTime, highValTimer);
			highValTimer = nPgmTime;
		}
		else if (!(abs(gMotor[shooter].curPower) >= 100 || abs(gMotor[shooterY].curPower) >= 100))
			highValTimer = 0;

		if ((nPgmTime - highValTimer) > highValLimit && highValTimer!= 0 && !killed)
		{
			writeDebugStreamLine("%d KILL SHOOTER - HIGH MOTOR START TIME: %d", nPgmTime, highValTimer);
			killShooter();

			killed = true;

			sleep(500);
		}
		sleep(10);
	}
}


task main()
{
	clearDebugStream();
	setupSensors();
	setupMotors();
	setupJoysticks();
	//tInit();

	clearDebugStream();
	int nBatteryLevel = nImmediateBatteryLevel;
	writeDebugStream("%d Battery: %d", nPgmTime, nBatteryLevel);

	//Setup Joystics
	enableJoystick(BTN_SHOOT);
	enableJoystick(BTN_ANGLER_TEST);
	enableJoystick(JOY_ANGLER);
	enableJoystick(JOY_THROTTLE);
	enableJoystick(JOY_TURN);

	resetQuadratureEncoder(ballDetector);

	startTask(updateVals);

	startTask(intakeAnglerTask);
	startTask(intakeTask);
	startTask(shooterTask);
	startTask(shooterMonitor);
	startTask(shooterSafety);
	startTask(driveTask);
	while(true) sleep(10);
	stopTask(intakeAnglerTask);
	stopTask(shooterTask);
	stopTask(intakeTask);
	stopTask(shooterMonitor);
	stopTask(shooterSafety);
	stopTask(driveTask);

	stopTask(updateVals);
}
