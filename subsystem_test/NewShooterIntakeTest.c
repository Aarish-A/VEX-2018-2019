#pragma config(Sensor, in1,    ballDetector,         sensorLineFollower)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,           intake,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           shooterA,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterRevSplit, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "../src/task.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "utilities.h"
#include "auto.h"

// Year-independent libraries (source)
#include "task.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "utilities.c"

//#define LIM_TO_VAL(input, val) (abs(input) > (val) ? (val) * sgn(input) : (input))
#define SHOOTER_GEAR_RATIO 1.0
#define SHOOTER_RELOAD_VAL (360.0*SHOOTER_GEAR_RATIO)
#define SHOOTER_RELOAD_HOLD 11

int gShooterPow;
/*
task printEnc()
{
	while (true)
	{
		datalogDataGroupStart();
		datalogAddValue(1, SensorValue[shooterEnc]);
		datalogAddValue(2, gShooterPow);
		datalogDataGroupEnd();

		sleep(10);
	}
}
*/
typedef enum _tSpinDir
{
	spinStop,
	spinUp,
	spinDown
}tSpinDir;

task intakeTask()
{
	bool buttonUP, lstButtonUp, buttonDown, lstButtonDown, buttonStop, lstButtonStop;
	tSpinDir spinDir = spinStop;

	while (true)
	{
		buttonUp = vexRT[btn6u];
		buttonDown = vexRT[btn6d];

		//writeDebugStreamLine("spindir=%d", spinDir);
		if (buttonUp && !lstButtonUp)
		{
			if (spinDir != spinStop)
				spinDir = spinStop;
			else
				spinDir = spinUp;
		}
		if (buttonDown && !lstButtonDown)
		{
			if (spinDir != spinStop)
				spinDir = spinStop;
			else
				spinDir = spinDown;
		}

		switch (spinDir)
		{
			case spinStop:
				motor[intake] = 0;
				break;
			case spinUp:
				motor[intake] = 127;
				break;
			case spinDown:
				motor[intake] = -127;
				break;
		}

		lstButtonUp = buttonUp;
		lstButtonDown = buttonDown;
		sleep(50);
	}
}

void setShooter(word val)
{
	//gMotor[shooterA].power = gMotor[shooterB].power = LIM_TO_VAL(val, 127);
	gShooterPow = LIM_TO_VAL(val, 127);
	gMotor[shooterA].power = gMotor[shooterRevSplit].power = LIM_TO_VAL(val, 127);
}


task shooterTask()
{
	//startTask(printEnc);
	clearDebugStream();
	int nBatteryLevel = nImmediateBatteryLevel;
	writeDebugStream("%d Battery: %d", nPgmTime, nBatteryLevel);
	int shooterShotCount = 0;
	resetQuadratureEncoder(shooterEnc);

	word button, lstButton;
	writeDebugStreamLine("Start");
	const float breakKp = -25.0;
	float shooterBreakOffset = 6;

	bool resetBackwards = false;
	while (true)
	{
		button = vexRT[Btn5U];

		if (button && !lstButton)
		{
			setShooter(127);
			writeDebugStreamLine("Setup shot #%d encoder start= %d", shooterShotCount,SensorValue[shooterEnc]);
			int target = shooterShotCount * SHOOTER_RELOAD_VAL;

			while (SensorValue[shooterEnc] < (target + 145)) {
				sleep(100);
				writeDebugStreamLine("Enc: %d", SensorValue[shooterEnc]);
			}
			writeDebugStreamLine("Enc: %d", SensorValue[shooterEnc]);
			setShooter(SHOOTER_RELOAD_HOLD);

			while (!vexRT[Btn5U]) sleep(10);

			if(SensorValue[ballDetector] > 1000)
			{
				setShooter(0);
				writeDebugStreamLine("%d No Ball", npgmtime);
				resetBackwards = true;
			}
			else if (SensorValue[ballDetector] >= 250 && SensorValue[ballDetector] <= 252)
			{
				setShooter(0);
				writeDebugStreamLine("%d Shooter Detector Unplugged", npgmtime);
				resetBackwards = true;
			}
			else
			{
				shooterShotCount++;
				target = shooterShotCount * SHOOTER_RELOAD_VAL;
				setShooter(127);
				unsigned long shootStartTime = npgmtime;
				writeDebugStreamLine("Fired shot #%d at %d, Tgt: %d, Enc: %d, Err: %d", shooterShotCount, nPgmTime, SensorValue[shooterEnc], target, target - SensorValue[shooterEnc]);
				while (SensorValue[shooterEnc] < (target-shooterBreakOffset) &&  SensorValue[ballDetector] < 1000 && npgmtime-shootStartTime < 500) sleep(10);
				writeDebugStreamLine("Forwards done at %d, Enc: %d", nPgmTime, SensorValue[shooterEnc]);
				setShooter(-22);
				sleep(80);
				writeDebugStreamLine("Break done at %d, Enc: %d", nPgmTime, SensorValue[shooterEnc]);
				setShooter(0);
				writeDebugStreamLine("Hold done at %d, Tgt: %d, Enc: %d, Err: %d", nPgmTime, target, SensorValue[shooterEnc], target - SensorValue[shooterEnc]);
				//writeDebugStreamLine("%dStart break %d, %d", npgmtime, shooterShotCount, SensorValue[shooterEnc]);

				resetBackwards = false;
			}
		}
		else
		{
			int senValLst, senVal;
			float senVelocity;
			unsigned long senTimeLst, senTime;
			senVal = SensorValue[shooterEnc];
			senTime = npgmtime;

			senVelocity = senVal-senValLst/senTime-senTimeLst;
			float offsetKp=1.27;
			int acceptableRange=9;
			word power;
			int offsetFromReset = SensorValue[shooterEnc]%360;
			velocityCheck(shooterEnc);
			writeDebugStreamLine("%d offsetFromReset:%d, pow:%d, vel:%f ", npgmtime, offsetFromReset, power, gSensor[shooterEnc].velocity);
			if (offsetFromReset >acceptableRange && offsetFromReset<360-acceptableRange && abs(gSensor[shooterEnc].velocity)<0.02)
			{
				if(offsetFromReset>180 && !resetBackwards) power = (offsetKp*(356-offsetFromReset));
				else power=(-1*offsetKp*offsetFromReset);
			}
			else
			{
				power=0;
			}
			setShooter(power);

			senValLst = senVal;
			senTimeLst = senTime;
		}
		lstButton = button;

		sleep(10);
	}
	//stopTask(printEnc);
}

task updateVals()
{
	writeDebugStreamLine("%d Start update", npgmtime);
	while (true)
	{
		hogCPU();
		updateJoysticks();
		updateMotors();
		updateSensorInputs();
		updateSensorOutputs();
		//writeDebugStreamLine("Update-shooter:%d", gSensor[shooterEnc].value);
		releaseCPU();
		sleep(10);
	}
}

task main()
{
	clearDebugStream();
	setupSensors();
	setupMotors();
	setupJoysticks();
	tInit();

	startTask(updateVals);

	startTask(intakeTask);
	startTask(shooterTask);
	while(true) sleep(10);
	stopTask(shooterTask);
	stopTask(intakeTask);
}
