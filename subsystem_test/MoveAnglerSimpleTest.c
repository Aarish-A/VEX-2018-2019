#pragma config(Sensor, in1,    ballDetector,   sensorLineFollower)
#pragma config(Sensor, in8,    anglerPoti,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,           driveLY,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterY,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           angler,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRY,       tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define LIM_TO_VAL(input, val) (abs(input) > (val) ? (val) * sgn(input) : (input))

void setAngler(word val)
{
	motor[angler] = LIM_TO_VAL(val, 127);
}

void moveAngler(int target)
{
	int bias  = 15;
	float kP = 0.5;


}

void moveAnglerSimple(int target)
{
	unsigned long moveStartTime = npgmtime;
	float percentFull = 0.40;
	float percentDecel = 0.95;
	float percentBreak = 0.98;
	int decelSpeed = 68;
	bool BtnAngleUp, BtnAngleUpLst;

	int bias = 7;

	int dir = sgn(target - SensorValue[anglerPoti]);

	if (dir == 1)
	{
		setAngler(127);
		while(SensorValue[anglerPoti]<(percentFull*target))
		{
			sleep(10);
		}

		unsigned long decelStartTime = npgmtime;
		while(SensorValue[anglerPoti]<(percentDecel*target))
		{
			int error = target-SensorValue[anglerPoti];
			setAngler((error*0.22));

			sleep(10);
		}

		//while(SensorValue[anglerPoti] < (target*percentBreak))
		//{
		//	setAngler(-20);
		//	sleep(10);
		//}
		setAngler(-20);
		int sen = 0;
		int lstSen = 0;
		unsigned long time, lstTime, tElpsdTime;
		unsigned long startBreakTime = npgmtime;
		float vel;
		do
		{
			time = npgmtime;
			sen = SensorValue[anglerPoti];

			int dif = (sen-lstSen);
			unsigned long elpsdTime = time - lstTime;
			writeDebugStreamLine("%d time: %d, dif:%d, cur:%d - lst:%d v:%f", npgmtime, elpsdTime, dif, sen, lstSen, dif/elpsdTime);

			if (elpsdTime > 0)
				vel = (float)(dif)/(elpsdTime);
			else
				vel =  0;

			int power = vel * -7;
			setAngler(power);

			lstSen = sen;
			writeDebugStreamLine("%d Break, vel: %f, pow: %d", npgmtime, vel, power);
			lstTime = time;
			sleep(10);

			tElpsdTime = npgmtime - startBreakTime;
		}while (SensorValue[anglerPoti] < (target*percentBreak) && vel >= -0.0001 && tElpsdTime < 100 );

		setAngler(9);
		sleep(300);
		writeDebugStreamLine("Intake Podi Value: %d",SensorValue[anglerPoti]);
	}
	writeDebugStreamLine("Move took %d", npgmtime-moveStartTime);

}

void moveAngler(int target)
{ // power down while distance > vel * K, break
	int bias = 10;
	int kP = 0.05;

	setAngler(-25);
	unsigned long startTime = npgmtime;
	while((npgmtime-startTime) < 250 && SensorValue[anglerPoti] > (target + 300)) sleep(10);

	while(SensorValue[anglerPoti] > (target + 10))
	{
		float power = ((target - SensorValue[anglerPoti]) * kP) + bias;
		setAngler(power);
		sleep(10);
	}
	setAngler(12);
	//break?

}

task main()
{
	bool bttn, bttnLst;
	while (true)
	{
		bttn = vexRT[Btn5D];

		if (bttn && !bttnLst)
		{
			//moveAnglerSimple(1200); //1200, 1060
			moveAnglerSimple(1200);
		}
		else
		{
			motor[angler] = 9;
		}
		sleep(10);
		bttnLst = bttn;
	}
}
