#pragma config(Sensor, in1,    ballDetector,   sensorLineFollower)
#pragma config(Sensor, in8,    anglerPoti,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,           driveLY,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterY,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           angler,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRY,       tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "../src/task.h"
//#include "motors.h"
#include "sensors.h"
//#include "joysticks.h"
#include "utilities.h"
#include "auto.h"
#include "cycle.h"

// Year-independent libraries (source)
#include "task.c"
//#include "motors.c"
#include "sensors.c"
//#include "joysticks.c"
#include "utilities.c"
#include "cycle.c"

#define JOY_ANGLER Ch2

//#define LIM_TO_VAL(input, val) (abs(input) > (val) ? (val) * sgn(input) : (input))

void setAngler(word val)
{
	motor[angler] = LIM_TO_VAL(val, 127);
}

void moveAnglerSimple(int target)
{
	unsigned long moveStartTime = npgmtime;
	float percentFull = 0.40;
	float percentDecel = 0.95;
	float percentBreak = 0.98;
	int decelSpeed = 68;
	bool BtnAngleUp, BtnAngleUpLst;

	int bias = 7;

	int dir = sgn(target - gSensor[anglerPoti].value);

	if (dir == 1)
	{
		setAngler(127);
		while(gSensor[anglerPoti].value<(percentFull*target))
		{
			sleep(10);
		}

		unsigned long decelStartTime = npgmtime;
		while(gSensor[anglerPoti].value<(percentDecel*target))
		{
			int error = target-gSensor[anglerPoti].value;
			setAngler((error*0.22));

			sleep(10);
		}

		//while(gSensor[anglerPoti].value < (target*percentBreak))
		//{
		//	setAngler(-20);
		//	sleep(10);
		//}
		setAngler(-20);
		int sen = 0;
		int lstSen = 0;
		unsigned long time, lstTime, tElpsdTime;
		unsigned long startBreakTime = npgmtime;
		float vel;
		do
		{
			time = npgmtime;
			sen = gSensor[anglerPoti].value;

			int dif = (sen-lstSen);
			unsigned long elpsdTime = time - lstTime;
			writeDebugStreamLine("%d time: %d, dif:%d, cur:%d - lst:%d v:%f", npgmtime, elpsdTime, dif, sen, lstSen, dif/elpsdTime);

			if (elpsdTime > 0)
				vel = (float)(dif)/(elpsdTime);
			else
				vel =  0;

			int power = vel * -70;
			setAngler(power);

			lstSen = sen;
			writeDebugStreamLine("%d Break, vel: %f, pow: %d", npgmtime, vel, power);
			lstTime = time;
			sleep(10);

			tElpsdTime = npgmtime - startBreakTime;
		}while (gSensor[anglerPoti].value < (target*percentBreak) && vel >= -0.0001 && tElpsdTime < 100 );

		setAngler(9);
		sleep(300);
		writeDebugStreamLine("Intake Podi Value: %d",gSensor[anglerPoti].value);
	}
	writeDebugStreamLine("Move took %d", npgmtime-moveStartTime);

}

void moveAngler(int target)
{ // power down while distance > vel * K, then break
	int bias = 13;//12;
	float kP = 0.043;

	setAngler(-25);
	int sen =  gSensor[anglerPoti].value;
	unsigned long startTime = npgmtime;
	int distance;
	float velDropOut = 20;
	float vel = gSensor[anglerPoti].velocity;
	float dropOut = (velDropOut*vel);
	int velOffset = 50;

	if (sen > 900 && sen < 1600)
	{
		setAngler(-20);
		velOffset = 10;
	}	else
	{
		velOffset = 50;
	}
	do
	{
		velocityCheck(anglerPoti, velOffset);
		sen =  gSensor[anglerPoti].value;
		vel = gSensor[anglerPoti].velocity;
		if (sen > 900 && sen < 1600)
		{
			velDropOut = 500;
		}
		else
		{
			velDropOut = 27;
		}

		dropOut = (velDropOut*vel);

		distance = target - sen;
		writeDebugStreamLine("%d Move, Sen:%d, D: %d, Vel: %f, FO: %d", npgmtime, sen, distance, vel, dropOut);
		sleep(10);
	}while((npgmtime-startTime) < 400 && abs(distance) > abs(dropOut));//gSensor[anglerPoti].value > (target + 200))

	startTime = npgmtime;
	while(gSensor[anglerPoti].value > (target + 18) && (npgmtime-startTime) < 400)
	{
		float power = ((target - gSensor[anglerPoti].value) * kP) + bias;
		writeDebugStreamLine("%d P:%d, T:%d, Pow:%d", npgmtime, gSensor[anglerPoti].value, target, power);
		setAngler(power);
		sleep(10);
	}
	setAngler(25);
	sleep(50);
	setAngler(12);
	//break?
}

void moveAnglerConstant(int target)
{
	setAngler(-30)
	while (gSensor[anglerPoti].value > (target + 200)) sleep(10);
	writeDebugStreamLine("%d Sen:%d", npgmtime, gSensor[anglerPoti].value);
	setAngler(30);
	unsigned long startTime = npgmtime;
	while (gSensor[anglerPoti].value > (target + 15) && (npgmtime-startTime) < 150) sleep(10);
	setAngler(10);
}

task updateVals()
{
	//writeDebugStreamLine("%d Start update", npgmtime);
	sCycleData cycle;
	initCycle(cycle, 10, "UpdateVals");
	while (true)
	{
		hogCPU();
		updateSensorInputs();
		updateSensorOutputs();
		////writeDebugStreamLine("Update-shooter:%d", gSensor[shooterEnc].value);
		releaseCPU();
		endCycle(cycle);
	}
}

task main()
{
	clearDebugStream();

	setupSensors();
	startTask(updateVals);

	bool bttn, bttnLst;
	while (true)
	{
		bttn = vexRT[Btn5D];

		if (bttn && !bttnLst)
		{
			//moveAnglerSimple(1200); //1200, 1060
			//moveAngler(1200);
			moveAnglerConstant(1060);
		}
		else if (abs(vexRT[JOY_ANGLER]) > 10 && (gSensor[anglerPoti].value > 510 && gSensor[anglerPoti].value < 3037))
		{
			setAngler(vexRT[JOY_ANGLER]);
		}
		else
		{
			setAngler(9);
		}
		sleep(10);
		bttnLst = bttn;
	}

	stopTask(updateVals);
}
