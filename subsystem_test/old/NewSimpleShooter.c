#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port5,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterY,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
unsigned char _hogLevel = 0;
//void tHog()
//{
//	if (!_hogLevel++)
//		hogCPU();
//}

//void tRelease()
//{
//	if (_hogLevel && !--_hogLevel)
//		releaseCPU();
//}
#include "../src/sensors.h"
#include "sensors.c"

#define BTN_SHOOT Btn5U
#define BTN_INTAKE_UP Btn6U
#define BTN_INTAKE_DOWN Btn6D

#define JOY_ANGLER Ch2
#define BTN_ANGLER_TEST Btn5D

#define JOY_THROTTLE Ch3
#define JOY_TURN Ch4

//#define LIM_TO_VAL(input, val) (abs(input) > (val) ? (val) * sgn(input) : (input))
#define RESET_OFFSET 45
#define SHOOTER_GEAR_RATIO 1.0
#define SHOOTER_RELOAD_VAL ((360.0*SHOOTER_GEAR_RATIO) + RESET_OFFSET)
#define SHOOTER_RELOAD_HOLD 11
#define SHOOTER_RELOAD_POS (145 + RESET_OFFSET)

#define BALL_DETECTED (gSensor[ballDetector].value < 1000 && (gSensor[ballDetector].value < 247 || gSensor[ballDetector].value > 252))

void killShooter();
int shooterShotCount;

bool shootTrigger;
task shooterTask()
{
	bool secondShot = false;
	shooterShotCount = 0;
	resetQuadratureEncoder(shooterEnc);

	//writeDebugStreamLine("Start");
	const float breakKp = -25.0;
	float shooterBreakOffset = 6;

	bool shotTargReached = false;

	bool cancelledPrint = false;
	shootTrigger = false;

	sleep(100);
	resetShooter();
	reloadShooter();

	while (true)
	{

		if (shootTrigger || vexRt[BTN_SHOOT])//RISING(BTN_SHOOT) )
		{
			writeDebugStreamLine("%d Shot Triggered", npgmtime);

			int target = shooterShotCount * SHOOTER_RELOAD_VAL;
			if (gSensor[shooterEnc].value < (target+SHOOTER_RELOAD_POS)) //Should only get triggered when shooterShotCount == 0
			{
				reloadShooter();
				while (!vexRT[BTN_SHOOT] && !shootTrigger) sleep(10);
			}

			if(gSensor[ballDetector].value > 1000 && !secondShot)
			{
				if (!cancelledPrint)
				{
					//writeDebugStreamLine("%d No Ball - Shot Cancelled");
					cancelledPrint = true;
				}
			}
			else if(gSensor[ballDetector].value >= 247 && gSensor[ballDetector].value <= 252)
			{
				if (!cancelledPrint)
				{
					writeDebugStreamLine("%d Ball Detector Unplugged - Shot Cancelled");
					cancelledPrint = true;
				}
			}
			else
			{
				cancelledPrint = false;
				unsigned long shotStartTime = npgmtime;
				writeDebugStreamLine("%d Shot Start", npgmtime);
				shooterShotCount++;
				target = shooterShotCount * SHOOTER_RELOAD_VAL;
				setShooter(127);
				//writeDebugStreamLine("Fired shot #%d at %d, Tgt: %d, Enc: %d, Err: %d", shooterShotCount, nPgmTime, gSensor[shooterEnc].value, target, target - gSensor[shooterEnc].value);

				shotTargReached = ( gSensor[shooterEnc].value > (target-shooterBreakOffset) );

				WHILE_SHOOTER_MOVING(10, 150, 700, !shotTargReached && (gSensor[shooterEnc].value < (target-65) || gSensor[shooterEnc].value > (target-15) || BALL_DETECTED))
				{
					shotTargReached = ( gSensor[shooterEnc].value > (target-shooterBreakOffset) );

					unsigned long timeElpsd = npgmtime-shotStartTime;

					sleep(10);
				}
				if (!shotTargReached)
				{
					writeDebugStreamLine("%d Ball gone: Val:%d, Time: %d Pos:%d, Targ:%d ", npgmtime, gSensor[ballDetector].value, npgmtime-shotStartTime, gSensor[shooterEnc].value, target);
					setShooter(-90);
					sleep(80);
					setShooter(0);
					shooterShotCount--;
					while (gSensor[shooterEnc].value > (target + SHOOTER_RELOAD_POS)) sleep(10);
					setShooter(11);
					PlayTone(300, 50);
					shootTrigger = false;
				}
				else
				{
					//writeDebugStreamLine("%d Shot done accelerating: Time: %d Pos:%d ", npgmtime, npgmtime-shotStartTime, gSensor[shooterEnc].value);
					setShooter(-22);
					unsigned long startBreakTime = npgmtime;
					while ((npgmtime-startBreakTime) < 80)
					{
						//writeDebugStreamLine("%d Break", npgmtime);
						if (gSensor[ballDetector].value > 2000)
						{
							//writeDebugStreamLine("	%d Ball hit: Time: %d", npgmtime, npgmtime-shotStartTime);
						}
						sleep(10);
					}
					//sleep(80);
					//writeDebugStreamLine("Break done at %d, Enc: %d", nPgmTime, gSensor[shooterEnc].value);
					setShooter(0);
					//writeDebugStreamLine("Hold done at %d, Tgt: %d, Enc: %d, Err: %d", nPgmTime, target, gSensor[shooterEnc].value, target - gSensor[shooterEnc].value);
					////writeDebugStreamLine("%dStart break %d, %d", npgmtime, shooterShotCount, gSensor[shooterEnc].value);
					//sleep(50);
					shootTrigger = false;
					writeDebugStreamLine("%d Shoot Trigger False - shot end", npgmtime);
					reloadShooter();
					//writeDebugStreamLine("%d Total Shot Time:%d", npgmtime, npgmtime-shotStartTime);

					if (!secondShot && vexRT[BTN_SHOOT]) secondShot = true;
					else if (secondShot) secondShot = false;
				}
			}
		}

		sleep(10);
	}
	//stopTask(printEnc);
}

task main()
{



}
