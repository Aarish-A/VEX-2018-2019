#pragma config(Sensor, in1,    ballDetector,   sensorLineFollower)
#pragma config(Sensor, in8,    anglerPoti,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  LED1,           sensorLEDtoVCC)
#pragma config(Motor,  port2,           driveLY,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterY,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           angler,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRY,       tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

unsigned char _hogLevel = 0;
void tHog()
{
	if (!_hogLevel++)
		hogCPU();
}

void tRelease()
{
	if (_hogLevel && !--_hogLevel)
		releaseCPU();
}

#define LIM_TO_VAL(input, val) (abs(input) > (val) ? (val) * sgn(input) : (input))

/* Angler Controls */
#define JOY_ANGLER Ch2
#define BTN_ANGLER_TEST Btn5D

#define ANGLER_BOTTOM_POS  330
#define ANGLER_HORIZONTAL_POS 1165
#define ANGLER_TOP_POS 3866

#define ANGLER_AXEL_POS (ANGLER_TOP_POS-1850)

//Positions shooting from back
#define ANGLER_BACK_TOP_FLAG 1320;//1415
#define ANGLER_BACK_MID_FLAG 1100;//1265//1165
#define ANGLER_BACK_BOTTOM_FLAG 955

int gAnglerPower = 0;
void setAngler(word val)
{
	gAnglerPower = LIM_TO_VAL(val, 127);
	motor[angler] = LIM_TO_VAL(val, 127);
}

typedef enum _tAnglerState
{
	anglerIdle,
	anglerMove,
	anglerHold,
	anglerManual
} tAnglerState;

unsigned long gAnglerBtnTime = 0;

tAnglerState gAnglerState = anglerIdle;
tAnglerState gAnglerStateLst = gAnglerState;
unsigned long gAnglerStateTime = nPgmTime;
int gAnglerStateSen = SensorValue[anglerPoti];

int gAnglerTarget = ANGLER_BOTTOM_POS + 300;
int gAnglerGoodCount = 0;

void setAnglerState (tAnglerState state)
{
	tHog();
	if (state != gAnglerState)
	{
		gAnglerStateLst = gAnglerState;
		gAnglerState = state;

		gAnglerStateTime = nPgmTime;
		gAnglerStateSen = SensorValue[anglerPoti];
		writeDebugStream("%d Angler State Set %d ", nPgmTime, gAnglerState);
		switch(gAnglerState)
		{
			case anglerIdle: writeDebugStream("anglerIdle"); break;
			case anglerMove: writeDebugStream("anglerMove"); break;
			case anglerHold: writeDebugStream("anglerHold"); break;
			case anglerManual: writeDebugStream("anglerManual"); break;

			default: writeDebugStream("UNKNOWN STATE"); break;
		}
		writeDebugStreamLine(". Targ:%d, Sen:%d, Time:%d, GoodCount:%d", gAnglerTarget, gAnglerStateSen, gAnglerStateTime, gAnglerGoodCount);
	}
	tRelease();
}

task anglerStateSet()
{
	unsigned long time = nPgmTime;
	unsigned long timeLst = 0;
	unsigned long deltaTime = 0;
	unsigned long sen = 0;
	unsigned long senLst = 0;
	unsigned long deltaSen = 0;

	float kP = 0.095;//0.09;
	float kI = 0.048;//0.016;
	float iVal, pVal;

	while (true)
	{
		switch (gAnglerState)
		{
			case anglerIdle:
			{
				setAngler(0);
				break;
			}
			case anglerMove:
			{
				gAnglerGoodCount = 0;
				if (SensorValue[anglerPoti] < gAnglerTarget)
				{
					float kP = 0.3;
					int targ = gAnglerTarget-200;
					while(SensorValue[anglerPoti] < targ)
					{
						tHog();
						int error = gAnglerTarget - SensorValue[anglerPoti];
						float power = error * kP;
						if (abs(SensorValue[anglerPoti]-ANGLER_HORIZONTAL_POS) < 250) power+=6;
						setAngler(power);
						tRelease();
						sleep(10);
					}
					setAngler(-15);
					unsigned long startBreakTime = nPgmTime;
					float vel = 10;
					do
					{
						sen = SensorValue[anglerPoti];
						time = nPgmTime;

						vel = (float)(sen-senLst)/(float)(time-timeLst);

						writeDebugStreamLine("%d Break. Pos:%d, Vel:%f", nPgmTime, sen, vel);
						senLst = sen;
						timeLst = time;
						sleep(10);
					} while ((vel > 2.7 && (nPgmTime-startBreakTime) < 100) || (nPgmTime-startBreakTime) < 20);
					setAngler(0);
				}
				setAnglerState(anglerHold);
				break;
			}
			case anglerHold:
			{
				tHog();
				time = nPgmTime;
				sen = SensorValue[anglerPoti];

				int error = gAnglerTarget - SensorValue[anglerPoti];
				float pVal = error * kP;

				unsigned long deltaTime = time-timeLst;
				deltaSen = sen - senLst;
				if (deltaTime <= 0 || abs(deltaSen) > 2 || abs(error) < 10)// || gAnglerStateLst == anglerManual)
				{
					iVal = 0;
				}
				else iVal += ( (float)error / (float)(deltaTime) ) * kI;

				if (abs(deltaSen) < 5 && abs(error) < 70)//25)
				{
					gAnglerGoodCount++;
					SensorValue[LED1] = 300;
					//writeDebugStreamLine("%d Angler Stopped at %d. Inc gAnglerGoodCount to %d", nPgmTime, SensorValue[anglerPoti], gAnglerGoodCount);
				}
				else
				{
					gAnglerGoodCount = 0;
					SensorValue[LED1] = 0;
				}

				int power = pVal + iVal;// + 5;
				if (SensorValue[anglerPoti] < gAnglerTarget && abs(SensorValue[anglerPoti]-ANGLER_HORIZONTAL_POS) < 250) power+=6;

				setAngler(power);

				//if(gAnglerStateLst == anglerMove)
				unsigned long tElpsd = (nPgmTime-gAnglerStateTime);
				if((tElpsd < 100) || (tElpsd > 700 && tElpsd < 850))
					writeDebugStreamLine("%d Sen:%d, Err: %d, pVal:%f, iVal:%f, pow: %f, dT:%d, dS:%d", nPgmTime, SensorValue[anglerPoti], error, pVal, iVal, power, deltaTime, deltaSen);
				if (gAnglerGoodCount == 5) writeDebugStreamLine("		%d Done hold to %d in %d ms. vel:%f. Sen:%d", nPgmTime, gAnglerTarget, (nPgmTime-gAnglerBtnTime), (deltaSen/deltaTime), SensorValue[anglerpoti]);
				senLst = sen;
				timeLst = time;

				//datalogDataGroupStart();
				//datalogAddValue(0, SensorValue[anglerPoti]);
				//datalogAddValue(1, (pVal*10.0));
				//datalogAddValue(2, (iVal*10.0));
				//datalogAddValue(3, gAnglerPower);
				//datalogAddValue(4, SensorValue[shooterEnc]);
				//datalogAddValue(5, SensorValue[ballDetector]);
				//datalogDataGroupEnd();

				tRelease();
				break;
			}
			case anglerManual:
			{
				if (abs(vexRT[Ch2]) > 10)
				{
					if (vexRT[Ch2] > 0 && SensorValue[anglerPoti] < (ANGLER_TOP_POS - 100))
					{
						setAngler(vexRT[Ch2]);
						//if (SensorValue[anglerPoti] > ANGLER_AXEL_POS && SensorValue[shooterEnc] > (SHOOTER_RELOAD_POS-10)) goto AnglerHoldTrigger;
					}
					else if (vexRT[Ch2] < 0 && SensorValue[anglerPoti] > (ANGLER_BOTTOM_POS + 100)) setAngler(vexRT[Ch2]);
					else goto AnglerHoldTrigger;
				}
				else
				{
					AnglerHoldTrigger:
					setAngler(0);
					sleep(100);
					gAnglerTarget = SensorValue[anglerPoti];
					setAnglerState(anglerHold);
				}
				break;
			}
		}

		//tHog();
		//datalogDataGroupStart();
		//datalogAddValue(0, SensorValue[anglerPoti]);
		//datalogAddValue(1, (pVal*10.0));
		//datalogAddValue(2, (iVal*10.0));
		//datalogAddValue(3, gAnglerPower);
		//datalogAddValue(4, SensorValue[shooterEnc]);
		//datalogAddValue(5, SensorValue[ballDetector]);
		//datalogDataGroupEnd();
		//tRelease();
		sleep(10);
	}
}

task main()
{
	clearDebugStream();
	datalogClear();
	startTask(anglerStateSet);
	bool btn, btnLst;
	sleep(500);
	while(true)
	{
		btn = vexRT[BTN_ANGLER_TEST];


		if (btn && !btnLst)
		{
			writeDebugStreamLine("%d Button Pressed", nPgmTime);
			//gAnglerTarget = ;
			//gAnglerGoodCount = 0;
			//setAnglerState(anglerHold);
			gAnglerGoodCount = 0;
			gAnglerTarget = ANGLER_BACK_MID_FLAG;
			setAnglerState(anglerMove);
			gAnglerBtnTime = nPgmTime;
			while (gAnglerGoodCount < 5) sleep(10);
			writeDEbugStreamLine("%d Done first move at %d", nPgmTime, SensorValue[anglerPoti]);

			gAnglerGoodCount = 0;
			gAnglerTarget = ANGLER_BACK_TOP_FLAG;
			setAnglerState(anglerMove);
			gAnglerBtnTime = nPgmTime;
			while (gAnglerGoodCount < 5) sleep(10);
			writeDEbugStreamLine("%d Done second move at %d", nPgmTime, SensorValue[anglerPoti]);
		}
		else if (abs(vexRT[JOY_ANGLER]) > 15) setAnglerState(anglerManual);

		btnLst = btn;
		sleep(10);
	}
	stopTask(anglerStateSet);

}
