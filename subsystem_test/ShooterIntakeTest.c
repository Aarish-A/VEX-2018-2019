#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,            ,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooterA,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           shooterB,      tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "../src/task.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "utilities.h"
#include "auto.h"

// Year-independent libraries (source)
#include "task.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "utilities.c"

#define SHOOTER_GEAR_RATIO 1.0
#define SHOOTER_RELOAD_VAL (360.0*SHOOTER_GEAR_RATIO)
#define BTN_SHOOT Btn6U

void setShooter(word val)
{
	gMotor[shooterA].power = gMotor[shooterB].power = LIM_TO_VAL(val, 127);
	//motor[shooterA] = motor[shooterB] = LIM_TO_VAL(val, 127);
}

typedef enum _tSpinDir
{
	spinStop,
	spinUp,
	spinDown
} tSpinDir;

lastSpinDir = Spintop;
task rollers()
{
	bool buttonUp, buttonUpLast, buttonDown, buttonDownLast;
	tSpinDir spinDir = spinStop;
	writeDebugStreamLine("Started intake task");

	while(true)
	{
		buttonUp = vexRT[Btn5U];
		buttonDown = vexRT[Btn5D];

		if (buttonUp && !buttonUpLast)
		{
			if (spinDir == spinUp) spinDir = spinStop;
			else spinDir = spinUp;
			writeDebugStreamLine("Up");
		}

		if (buttonDown && !buttonDownLast)
		{
			if (spinDir == spinDown) spinDir = spinStop;
			else {
				spinDir = spinDown;
				writeDebugStreamLine("Down");
			}
		}

		switch(spinDir)
		{
			case spinStop:
			  writeDebugStreamLine("Stop");
				motor[intake] = 0;
				break;
			case spinUp:
				writeDebugStreamLine("SpinUp");
				motor[intake] = 127;
				break;
			case spinDown:
				writeDebugStreamLine("SpinStop");
				motor[intake] = -127;
				break;
		}

		buttonUpLast = buttonUp;
		buttonDownLast = buttonDown;
		sleep(10);
	}
}

task updateVals()
{
	writeDebugStreamLine("%d Start update", npgmtime);
	while (true)
	{
		hogCPU();
		updateJoysticks();
		updateMotors();
		updateSensorInputs();
		updateSensorOutputs();
		//writeDebugStreamLine("Update-shooter:%d", gSensor[shooterEnc].value);
		releaseCPU();
		sleep(10);
	}
}

task main()
{
	clearDebugStream();
	setupSensors();
	setupMotors();
	setupJoysticks();
	tInit();
	startTask(rollers);

	//Setup Joysticks & Buttons
	enableJoystick(BTN_SHOOT);

	resetQuadratureEncoder(shooterEnc);
	startTask(updateVals);
	int shooterShotCount = 0;

	//gSensor[shooterEnc].value = 0;

	bool button, lstButton;
	writeDebugStreamLine("Start");
	const float breakKp = -20.0;
	float shooterBreakOffset = 55.0;
	while (true)
	{
		//button = vexRT[Btn6U];

		//if (button && !lstButton)
		if (RISING(BTN_SHOOT))
		{
			shooterShotCount++;
			int target = shooterShotCount * SHOOTER_RELOAD_VAL;

			setShooter(127);
			writeDebugStreamLine("Started shot #%d at %d, E: %d, T: %d", shooterShotCount, nPgmTime, gSensor[shooterEnc].value, target);
			while (gSensor[shooterEnc].value < (target-shooterBreakOffset))
			{
				writeDebugStreamLine("Enc: %d, Target: %d", gSensor[shooterEnc].value, target);
				sleep(10);
			}
			//setShooter(0);
			writeDebugStreamLine("Started breaking at %d, %d", npgmtime, gSensor[shooterEnc].value);

			do //Break
			{
				velocityCheck(shooterEnc, 2);
				float value = gSensor[shooterEnc].value;
				float velocity = gSensor[shooterEnc].velocity;

				int power = breakKp * abs(velocity);
				setShooter(power);
				writeDebugStreamLine("%d loc:%d vel:%f, pow:%f", npgmtime, value, velocity, power);

				sleep(10);
			} while(gSensor[shooterEnc].velocity > 0.5); //gSensor[shooterEnc].value < target &&

			setShooter(0);
			writeDebugStreamLine("Ended shot at #%d at %d, E: %d, T: %d, Err: %d", shooterShotCount, nPgmTime, gSensor[shooterEnc].value, target, target - gSensor[shooterEnc].value);
			sleep(30);
			//writeDebugStreamLine("%After 30ms coast %d(t:%d), %d", nPgmTime, shooterShotCount, target, gSensor[shooterEnc].value);
		}

		//lstButton = button;
		sleep(10);
	}

	stopTask(updateVals);
}
