#pragma config(Sensor, in1,    ballDetector,         sensorLineFollower)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveLP,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveLS,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooterA,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterRevSplit, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveRP,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           driveRS,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int nBatteryLevel;

//#define FORCE_AUTO 1

#define DATALOG_BATTERY -1

#define CHECK_POTI_JUMPS 1
#define DRIVE_TURN (gJoy[JOY_TURN].cur - gJoy[JOY_TURN].deadzone * sgn(gJoy[JOY_TURN].cur))

//#include "state_test.h"
#include "state.h"
#include "func_to_state.h"

// Year-independent libraries (headers)
#include "task.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "auto.h"

// Year-independent libraries (source)
#include "task.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"

// Other includes
#include "Vex_Competition_Includes_Custom.c"
#include "controls.h"

/* Drive Controls */
void setDrive(word left, word right)
{
	//writeDebugStreamLine("%d l:%d, r:%d", npgmtime, left, right);
	gMotor[driveLP].power = gMotor[driveLS].power = LIM_TO_VAL(left, 127);
	gMotor[driveRP].power = gMotor[driveRS].power = LIM_TO_VAL(right, 127);
}

CREATE_MACHINE_3(drive, trackL, Idle, Break, Manual, float, Vel, int, Power);
//#include "driveTest.c"
#include "auto.c"
#include "drive_algs.h"
#include "drive_algs.c"

task driveSet()
{
	driveLogs = 1; // Toggle Logging

	sCycleData cycle;
	initCycle(cycle, 10, "drive");
	while (true)
	{
		switch(driveState)
		{
		case driveIdle: //0:
			{
				driveBlocked = 0;
				setDrive(0,0);

				driveStateCycCount++;
				break;
			}
		case driveBreak: //1:
			{
				driveBlocked = 0;
				float startVelL, startVelR;

				const float velThresh = 0.015;
				velocityCheck(trackL);
				velocityCheck(trackR);
				float left = gSensor[trackL].velocity;
				float right = gSensor[trackR].velocity;
				if (driveStateCycCount == 0)
				{
					startVelL = left;
					startVelR = right;
					LOG(drive)("BreakFirstVel %f, %f", startVelL, startVelR);
				}

				LOG(drive)("L: %f, r: %f", left, right);
				if (( abs(left) < velThresh || sgn(left)!=sgn(startVelL) ) && ( abs(right) < velThresh || sgn(right)!=sgn(startVelR) ) )
				{
					driveStateChange(driveIdle);
				}
				else
				{
					setDrive((abs(left) > velThresh? (LIM_TO_VAL(sgn(left) * -50, 12)) : 0), (abs(right) > velThresh? (LIM_TO_VAL(sgn(right) * -50, 12)) : 0) );
				}
				driveStateCycCount++;

				driveSafetyCheck(driveIdle);
				break;
			}
		case driveManual: //2:
			{
				driveBlocked = 0;
				//float angleToTen = atan2( (gPosition.x - 0), (gPosition.y - 10) );
				setDrive((LIM_TO_VAL((gJoy[JOY_THROTTLE].cur + DRIVE_TURN), 127)), (LIM_TO_VAL((gJoy[JOY_THROTTLE].cur - DRIVE_TURN), 127)));
				driveStateCycCount++;

				LOG(drive)("%d (%f,%f) a:%f", npgmtime, gPosition.x, gPosition.y, gPosition.a);

				break;
			}

			//ADD_FUNC_TO_SWITCH_VOID_4(driveFuncTest, drive, driveBreak, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_7(followLineVec, drive, driveIdle, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_6(followLine, drive, driveIdle, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_6(moveToTargetSimple, drive, driveIdle, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_12(moveToTarget, drive, driveIdle, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_12(moveToTargetDis, drive, driveBreak, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_7(turnToAngleNewAlg, drive, driveBreak, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_9(turnToTargetNewAlg, drive, driveBreak, driveIdle)
			ADD_FUNC_TO_SWITCH_VOID_7(sweepTurnToTarget, drive, driveBreak, driveIdle)
		}
		endCycle(cycle);
	}
}
void handleDrive()
{
	if (!gJoy[JOY_THROTTLE}.cur && !gJoy[JOY_TURN].cur && driveState == driveManual)
	{
		driveStateChange(driveBreak, false, 150);
	}
	else if(gJoy[JOY_THROTTLE}.cur || gJoy[JOY_TURN].cur)
	{
		driveStateChange(driveManual);
	}
}

CREATE_MACHINE_3(intake, trackL, Stop, Up, Down, int, Dir, int, Power);
#define INTAKE_UP_POWER 127
#define INTAKE_DOWN_POWER -127

task intakeSet()
{
	intakeLogs = 1; // Toggle Logging

	sCycleData cycle;
	initCycle(cycle, 10, "drive");
	while (true)
	{
		switch(intakeState)
		{
			case intakeStop:
				gMotor[intake].power = 0;
				break;
			case intakeUp:
				gMotor[intake].power = INTAKE_UP_POWER;
				break;
			case intakeDown:
				gMotor[intake].power = INTAKE_DOWN_POWER;
				break;
		}
		endCycle(cycle);
	}
}
void handleIntake()
{
		if (RISING(BTN_INTAKE_UP))
		{
			LOG(intake)("%d Intake Up Pressed", npgmtime);
			if (intakeState != intakeStop)
				intakeStateChange(intakeStop, false);
			else
				intakeStateChange(intakeUp, false);
		}
		else if (RISING(BTN_INTAKE_DOWN))
		{
			LOG(intake)("%d Intake Down Pressed", npgmtime);
			if (intakeState != intakeStop)
				intakeStateChange(intakeStop, false);
			else
				intakeStateChange(intakeDown, false);
		}
}

CREATE_MACHINE_4(shooter, shooterEnc, Idle, Reload, Shoot, Break, int, Dir, int, Power);
#define SHOOTER_GEAR_RATIO 1.0
#define SHOOTER_RELOAD_VAL (360.0*SHOOTER_GEAR_RATIO)

void setShooter(word val)
{
	motor[shooterA] = motor[shooterRevSplit] = LIM_TO_VAL(val, 127);
}

task shooterSet()
{
	int shooterShotCount = 0;

	resetQuadratureEncoder(shooterEnc);

	shooterLogs = 1; // Toggle Logging

	sCycleData cycle;
	initCycle(cycle, 10, "shooter");
	while (true)
	{
		switch(shooterState)
		{
			case shooterIdle:
				setShooter(0);
				break;
			case shooterReload:
				setShooter(127);
				writeDebugStreamLine("Setup shot #%d encoder start= %d", shooterShotCount,SensorValue[shooterEnc]);
				int target = shooterShotCount * SHOOTER_RELOAD_VAL;

				while (SensorValue[shooterEnc] < (target + 145)) {
					sleep(100);
					writeDebugStreamLine("Enc: %d", SensorValue[shooterEnc]);
				}
				writeDebugStreamLine("Enc: %d", SensorValue[shooterEnc]);
				setShooter(11);
				break;
			case shooterShoot:
				break;
			case shooterBreak;
				break;
		}
		endCycle(cycle);
	}
}
void handleShooter()
{

}

void startTasks()
{
	resetPositionFull(gPosition, 0, 0, 0);

	//tStart(autoMotorSensorUpdateTask);

	tStart(driveSet);
	tStart(intakeSet);
	tStart(shooterSet);
}

void stopTasks()
{
	tStop(trackPositionTask);

	//tStop(autoMotorSensorUpdateTask);

	tStop(driveSet);
	tStop(intakeSet);
	tStop(shooterSet);
}

void startup()
{
	clearDebugStream();
	setupSensors();
	setupMotors();
	setupJoysticks();
	tInit();

	//Setup Joysticks & Buttons
	enableJoystick(JOY_THROTTLE);
	enableJoystick(JOY_TURN);
	enableJoystick(BTN_INTAKE_UP);
	enableJoystick(BTN_INTAKE_DOWN);
	enableJoystick(BTN_SHOOT);

	gJoy[JOY_THROTTLE].deadzone = 15;
	gJoy[JOY_TURN].deadzone = 15;

}

void disabled()
{
	updateSensorInputs();
	//selectAuto();
	//handleLcd();
}

task autonomous()
{
	tStart(autoMotorSensorUpdateTask);
	startTasks();
	writeDebugStreamLine("%d Start Autonomous, %d", npgmtime, nBatteryLevel);

	sCycleData auto;
	initCycle(auto, 10, "auto");
	while(true)
	{
		endCycle(auto);
	}

	tStop(autoMotorSensorUpdateTask);
	stopTasks();
}

task usercontrol()
{
	sCycleData cycle;
	initCycle(cycle, 10, "usercontrol");

	writeDebugStream("%d Start usercontrol",npgmtime);

	startTasks();

	while (true)
	{
		updateJoysticks();
		updateMotors();
		updateSensorInputs();
		updateSensorOutputs();

		handleDrive();
		handleIntake();
		handleShooter();

		//setMobileState();

		endCycle(cycle);
	}
	stopTasks();
}
