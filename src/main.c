#pragma config(Sensor, in1,    anglerPoti,     sensorPotentiometer)
#pragma config(Sensor, in2,    decapperPoti,   sensorPotentiometer)
#pragma config(Sensor, in3,    autoPoti,       sensorAnalog)
#pragma config(Sensor, in8,    ballDetector,   sensorLineFollower)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  LED1,           sensorLEDtoVCC)
#pragma config(Motor,  port1,           decapper,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           driveLY,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           intake,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           driveL,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterY,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveR,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           angler,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRY,       tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define FORCE_AUTO

int gBatteryLevel;
int gBackupBatteryLevel;

#define MAX_ANGLE_TIME 1000
#define MAX_ANGLE_TIME_FRONT 700
#define SHOOTER_SHOOT_UNLOADED_TIME 790
#define SHOOTER_SHOOT_LOADED_TIME 500

/*			Toggle Logging 			*/
//#define DRIVE_LOGS 1
//#define DRIVE_STATE_LOGS 1

//#define INTAKE_LOGS 1
//#define INTAKE_STATE_LOGS 1

//#define DECAPPER_LOGS 1
#define DECAPPER_STATE_LOGS 1

//#define ANGLER_LOGS 1
#define ANGLER_STATE_LOGS 1
bool anglerDatalog = false;
bool anglerAlgLogs = false;

#define SHOOTER_LOGS 1

#define MACRO_LOGS 1

#define AUTO_LOGS 1

#include "log_toggle.h"
/* /////////////////////// */


#define LOG(machineIn) if(machineIn##Logs) writeDebugStreamLine

unsigned char _hogLevel = 0;
void tHog()
{
	if (!_hogLevel++)
		hogCPU();
}

void tRelease()
{
	if (_hogLevel && !--_hogLevel)
		releaseCPU();
}

/* Includes */
// Year-independent libraries (headers)
#include "cycle.h"
#include "motors.h"
#include "joysticks.h"
#include "utilities.h"
#include "tracking.h"
#include "custom_turning.h"

// Year-independent libraries (source)
#include "cycle.c"
#include "motors.c"
#include "joysticks.c"
#include "utilities.c"
#include "tracking.c"
#include "custom_turning.c"

// Other includes
#include "Vex_Competition_Includes_Custom.c"
#include "controls.h"

// Important globals
bool gAnglerShooterTaskRunning = false;
unsigned long gAnglerShooterTaskTime = 0;

//Initialize safeties
//#include "safety.h"
//#include "safety.c"
//sSafety driveSafety, shooterSafety, anglerSafety; //No intake safety
//void initSafeties()
//{
//	initSafety(driveSafety, "driveSafety", velSensor, trackL);
//	initSafety(shooterSafety, "shooterSafety", velSensor, shooterEnc);
//	initSafety(anglerSafety, "anglerSafety", velSensor, anglerPoti);
//}

/* Shooter Positions */
int gShootTuneMode = false;

int gShooterShotCount = 0;
#define RESET_OFFSET 45//43//40
#define SHOOTER_GEAR_RATIO 1.0
#define SHOOTER_RELOAD_HOLD 11
#define SHOOTER_SHOOT_POS ((gShooterShotCount*360.0*SHOOTER_GEAR_RATIO) + RESET_OFFSET)
#define SHOOTER_NEXT_SHOOT_POS (((1+gShooterShotCount)*360.0*SHOOTER_GEAR_RATIO) + RESET_OFFSET)
#define SHOOTER_RELOAD_POS ((SHOOTER_SHOOT_POS) + 185)//165)

/* Drive Controls */
typedef enum _tTurnDir
{
	turnNone,
	turnCW,
	turnCCW
} tTurnDir;

#define DRIVE_THROTTLE_DZ 15
#define DRIVE_TURN_DZ 10

sbyte gDriveThrottleRaw, gDriveTurnRaw,;

int gDrivePower, gDriveLength;

float gDriveTurnShootScale = 0.85;

bool gDriveFlip = false;

int gDriveBreakPow = 11;
unsigned long gDriveBreakWait = 500;

void setDrive(word left, word right)
{
	setMotor(driveL, left);
	setMotor(driveLY, left);
	setMotor(driveR, right);
	setMotor(driveRY, right);
}

//Auto Drive Algs
#include "drive_algs.h"
#include "drive_algs.c"

typedef enum _tDriveState
{
	driveIdle,
	driveManual,
	driveBackHold,
	driveMoveTime,
	driveBreak
} tDriveState;

tDriveState gDriveState = driveIdle;
tDriveState gDriveStateLst = gDriveState;
unsigned long gDriveStateTime;

tTurnDir gDriveTurnDir = turnNone;

void setDriveState (tDriveState state, int drivePower = -1, int driveLength = -1)
{
	tHog();
	if (state != gDriveState)
	{
		gDriveStateLst = gDriveState;
		gDriveState = state;

		//gDriveTurnDir = turnNone;

		gDriveStateTime = nPgmTime;

		gDrivePower = drivePower;
		gDriveLength = driveLength;

		#if defined (DRIVE_STATE_LOGS)
			writeDebugStream("%d Drive State Set %d ", nPgmTime, gDriveState);
			switch(gDriveState)
			{
			case driveIdle: writeDebugStream("driveIdle"); break;
			case driveManual: writeDebugStream("driveManual"); break;
			case driveBackHold: writeDebugStream("driveBackHold"); break;
			case driveMoveTime: writeDebugStream("driveMoveTime"); break;
			case driveBreak: writeDebugStream("driveBreak"); break;

			default: writeDebugStream("UNKNOWN STATE"); break;
			}
			writeDebugStreamLine(", turnDir: %d, pow: %d, length:%d, T:%d, vel:%d", gDriveTurnDir, gDrivePower, gDriveLength, gDriveStateTime, gVelocity.y);
		#endif
	}
	tRelease();
}

task driveStateSet()
{
	sCycleData driveCycle;
	initCycle(driveCycle, 10, "driveCycle");

	int throttle, turn;
	word left, right;

	motor[driveL] = motor[driveR] = motor[driveLY] = motor[driveRY] = 0;
	setDriveState(driveIdle);
	writeDebugStreamLine("%d Start Drive Machine. S:%d", nPgmTime, gDriveState);

	while (true)
	{
		switch(gDriveState)
		{
		case driveIdle:
			{
				setDrive(0, 0);
				break;
			}
		case driveManual:
			{
				if (abs(gDriveThrottleRaw) > DRIVE_THROTTLE_DZ) throttle = gDriveThrottleRaw;
				else throttle = 0;
				if (gDriveFlip) throttle *= -1;

				if (abs(gDriveTurnRaw) > DRIVE_TURN_DZ)
				{
					turn = lookupTurn(gDriveTurnRaw); //gDriveTurnRaw;

					if (gAnglerShooterTaskRunning) turn *=  gDriveTurnShootScale;

					gDriveTurnDir = (turn > 0)? turnCW : turnCCW;
				}
				else turn = 0;

				if ((nPgmTime-gDriveStateTime) < 50) gDriveTurnDir = turnNone; //For first 50ms of being in manual, turnDir reset to turnNone

				left = throttle + turn;
				right = throttle - turn;

				setDrive(left, right);

				if (!(abs(gDriveTurnRaw) > DRIVE_TURN_DZ) && !(abs(gDriveThrottleRaw) > DRIVE_THROTTLE_DZ)) setDriveState(driveBreak);

				break;
			}
		case driveBackHold:
		{
			//unsigned long startTime = nPgmTime;
			//if (nPgmTime < (driveStateTime+300)) setDrive(-50, 0);
			//else if (nPgmTime < (driveStateTime+300)) setDrive(0, -50);
			//if(nPgmTime < (gDriveStateTime+300))
			//{
			//	setDrive(-50, -50);
			//	LOG_DRIVE(("%d vel:%f", nPgmTime, gPosition.y))
			//	sleep(10);
			//}
			if(nPgmTime < (gDriveStateTime+450))
			{
				setDrive(-50, -15);
				//LOG_DRIVE(("right", nPgmTime, gPosition.y))
				sleep(10);
			}
			else if(nPgmTime < (gDriveStateTime+900))
			{
				setDrive(-15, -50);
				//LOG_DRIVE(("left", nPgmTime, gPosition.y))
				sleep(10);
			}
			else setDrive(-15, -15);
			break;
		}
		case driveMoveTime:
			{
				unsigned long timeCur = nPgmTime;
				unsigned long length = timeCur + gDriveLength;
				setDrive(gDrivePower, gDrivePower);
				while (nPgmTime < length) sleep(10);
				setDrive(0,0);

				setDriveState(driveIdle);
				break;
			}
		case driveBreak:
			{
				gDriveBreakPow = abs(gDriveBreakPow);
				gDriveBreakWait = abs(gDriveBreakWait);
				//LOG_DRIVE(("%d In breaking. DriveBreakPow:%d. TurnDir:%d", nPgmTime, gDrivebreakPow, gDriveTurnDir))

				if (gDriveTurnDir == turnCW) setDrive(-gDriveBreakPow, gDriveBreakPow);
				else if (gDriveTurnDir == turnCCW) setDrive(gDriveBreakPow, -gDriveBreakPow);

				if ((nPgmTime-gDriveStateTime) > gDriveBreakWait || gDriveTurnDir == turnNone) setDriveState(driveIdle);
				break;
			}
		}
		endCycle(driveCycle);
	}
}


/* Intake Controls */
void setIntake(word power)
{
	setMotor(intake, power);
}

typedef enum _tIntakeState
{
	intakeIdle,
	intakeCapHold,
	intakeUp,
	intakeDown

} tIntakeState;

tIntakeState gIntakeState = intakeIdle;
tIntakeState gIntakeStateLst = gIntakeState;
unsigned long gIntakeStateTime;

void setIntakeState (tIntakeState state)
{
	tHog();
	if (state != gIntakeState)
	{
		gIntakeStateLst = gIntakeState;
		gIntakeState = state;

		gIntakeStateTime = nPgmTime;

		#if defined (intakeStateLogs)
			writeDebugStream("%d Intake State Set %d ", nPgmTime, gIntakeState);
			switch(gIntakeState)
			{
			case intakeIdle: writeDebugStream("intakeIdle"); break;
			case intakeCapHold: writeDebugStream("intakeCapHold"); break;
			case intakeUp: writeDebugStream("intakeUp"); break;
			case intakeDown: writeDebugStream("intakeDown"); break;

			default: writeDebugStream("UNKNOWN STATE"); break;
			}
			writeDebugStreamLine(", AnglerSen:%d, T:%d", SensorValue[anglerPoti], gIntakeStateTime);
		#endif
	}
	tRelease();
}


task intakeStateSet()
{
	setIntakeState(intakeIdle);
	writeDebugStreamLine("%d Start Intake Machine. S:%d", nPgmTime, gIntakeState);

	while (true)
	{
		switch (gIntakeState)
		{
		case intakeIdle:
			{
				setIntake(0);
				break;
			}
		case intakeCapHold:
			{
				setIntake(-15);
				break;
			}
		case intakeUp:
			{
				setIntake(127);
				break;
			}
		case intakeDown:
			{
				setIntake(-60);
				break;
			}
		}
		sleep(10);
	}
}

void intakeControls()
{

	if (RISING(BTN_INTAKE_UP))
	{
		if (gJoy[BTN_SHIFT].cur)
		{
			gDriveFlip = !gDriveFlip;
		}
		else if (gIntakeState != intakeIdle)
		{
			if (gIntakeState == intakeDown) setIntakeState(intakeCapHold);
			else setIntakeState(intakeIdle);
		}
		else setIntakeState(intakeUp);
	}
	else if (RISING(BTN_INTAKE_DOWN))
	{
		if (gIntakeState != intakeIdle)
		{
			if (gIntakeState == intakeDown) setIntakeState(intakeCapHold);
			else setIntakeState(intakeIdle);
		}
		else setIntakeState(intakeDown);
	}
}


/* Decapper Controls */
#define DECAPPER_BOTTOM_POS 620
#define DECAPPER_TOP_POS 3030

#define DECAPPER_DZ 15

#define DECAPPER_HOLD_POS 2950

#define DECAPPER_GRAB_POS 2150
#define DECAPPER_DROP_POS (DECAPPER_BOTTOM_POS+50)

#define DECAPPER_CARRY_POS 1740//1290

void setDecapper(word power)
{
	setMotor(decapper, power);
}

typedef enum _tDecapperState
{
	decapperIdle,
	decapperHold,
	decapperManual,
	decapperUp,
	decapperDown
} tDecapperState;

tDecapperState gDecapperState = decapperIdle;
tDecapperState gDecapperStateLst = gDecapperState;
tDecapperState gDecapperStateLstLst = gDecapperStateLst;
unsigned long gDecapperStateTime;

int gDecapperTarget;
int gDecapperPower;
int gDecapperBreakPower;

void setDecapperState (tDecapperState state, int target = -1, int power = -1, int breakPower = -1)
{
	tHog();
	if (state != gDecapperState)
	{
		gDecapperStateLstLst = gDecapperStateLst;
		gDecapperStateLst = gDecapperState;
		gDecapperState = state;

		if (target != -1) gDecapperTarget = target;
		gDecapperPower = power;
		gDecapperBreakPower = breakPower;

		gDecapperStateTime = nPgmTime;

		#if defined (decapperStateLogs)
			writeDebugStream("%d Decapper State Set %d ", nPgmTime, gDecapperState);
			switch(gDecapperState)
			{
			case decapperIdle: writeDebugStream("decapperIdle"); break;
			case decapperHold: writeDebugStream("decapperHold"); break;
			case decapperManual: writeDebugStream("decapperManual"); break;
			case decapperUp: writeDebugStream("decapperUp"); break;
			case decapperDown: writeDebugStream("decapperDown"); break;

			default: writeDebugStream("UNKNOWN STATE"); break;
			}
			writeDebugStreamLine(", DecapperSen:%d, Targ:%d, pow:%d, bPow:%d, T:%d, Joy:%d, StateL:%d, StateLL:%d", SensorValue[decapperPoti], gDecapperTarget, gDecapperPower, gDecapperBreakPower, gDecapperStateTime, vexRT[JOY_DECAPPER], gDecapperStateLst, gDecapperStateLstLst);
		#endif
	}
	tRelease();
}


task decapperStateSet()
{
	setDecapperState(decapperIdle);
	writeDebugStreamLine("%d Start Decapper Machine. S:%d", nPgmTime, gDecapperState);

	while (true)
	{
		switch (gDecapperState)
		{
		case decapperIdle:
			{
				setDecapper(0);
				break;
			}
		case decapperHold:
			{
				//LOG_DECAPPER(("%d Decapper Hold", nPgmTime))
				if (SensorValue[decapperPoti] > DECAPPER_HOLD_POS) setDecapper(0);
				else if (SensorValue[decapperPoti] < (DECAPPER_BOTTOM_POS+250)) setDecapper(-10);
				else if (SensorValue[decapperPoti] < DECAPPER_HOLD_POS) setDecapper(15);
				break;
			}
		case decapperManual:
			{
				//LOG_DECAPPER(("%d Decapper Manual, %d", nPgmTime, gMotor[decapper].powerCur))
				int power = vexRT[JOY_DECAPPER];
				if (abs(power) < DECAPPER_DZ) power = 0;

				if (gAnglerShooterTaskRunning || abs(vexRT[JOY_DECAPPER]) < DECAPPER_DZ ||
					(power>0 && SensorValue[decapperPoti] > (DECAPPER_TOP_POS-150)) ||
					(power<0 && SensorValue[decapperPoti] < (DECAPPER_BOTTOM_POS+150)) )
						setDecapperState(decapperHold);
				else
					setDecapper(power);

				break;
			}
		case decapperUp:
			{
				setDecapper(gDecapperPower);
				while (SensorValue[decapperPoti] < (gDecapperTarget-100)) sleep(10);
				LOG_DECAPPER(("%d Decapper moved to %d", nPgmTime, SensorValue[decapperPoti]))
				setDecapper(gDecapperBreakPower);
				sleep(150);
				LOG_DECAPPER(("%d Decapper breaked to %d", nPgmTime, SensorValue[decapperPoti]))
				setDecapperState(decapperHold);

				break;
			}
		case decapperDown:
			{
				setDecapper(gDecapperPower);
				while (SensorValue[decapperPoti] > (gDecapperTarget+100)) sleep(10);
				LOG_DECAPPER(("%d Decapper moved to %d", nPgmTime, SensorValue[decapperPoti]))
				setDecapper(gDecapperBreakPower);
				sleep(70);
				LOG_DECAPPER(("%d Decapper breaked to %d", nPgmTime, SensorValue[decapperPoti]))
				setDecapperState(decapperHold);

				break;
			}
		}
		sleep(10);
	}
}

bool doExtraRaise = false;

void decapperControls()
{

	if (doExtraRaise && SensorValue[decapperPoti] > (DECAPPER_GRAB_POS+200))
	{
		LOG_DECAPPER(("%d DO extra lift. Pos:%d", nPgmTime, SensorValue[decapperPoti]))
		setDecapperState(decapperUp, (DECAPPER_TOP_POS-150), 100, 0);
		doExtraRaise = false;
	}

	if(RISING(BTN_DECAPPER_MOVE))
	{
		if (gJoy[BTN_SHIFT].cur)
		{
			//if (SensorValue[decapperPoti] > (DECAPPER_GRAB_POS-100))
			//	setDecapperState(decapperUp, DECAPPER_TOP_POS, 60);
			//else
				setDecapperState(decapperDown, DECAPPER_DROP_POS, -40, 15);
		}
		else
		{
		if (SensorValue[decapperPoti] < DECAPPER_CARRY_POS)
		{
			setDecapperState(decapperUp, DECAPPER_GRAB_POS, 127, -15);
			doExtraRaise = true;
		}
		else
		{
			setDecapperState(decapperDown, DECAPPER_CARRY_POS, -25, 10);
		}
		}

	}
	else if (abs(vexRT[JOY_DECAPPER]) > DECAPPER_DZ && !gAnglerShooterTaskRunning)
		// &&	!((vexRT[JOY_DECAPPER]>0 && SensorValue[decapperPoti] > (DECAPPER_TOP_POS-150)) ||(vexRT[JOY_DECAPPER]<0 && SensorValue[decapperPoti] < (DECAPPER_BOTTOM_POS+150)))	)
		setDecapperState(decapperManual);


	//Safety
	if ((gDecapperState == decapperUp || gDecapperState == decapperDown) && (nPgmTime-gDecapperStateTime) > 2000)
	{
		stopTask(decapperStateSet);
		startTask(decapperStateSet);
		LOG_DECAPPER(("%d Decapper TO", nPgmTime))
		setDecapperState(decapperIdle);
	}
}

//int gAnglerTarget = 1000;
/* Angler Controls */
#define ANGLER_DZ 15

#define ANGLER_BOTTOM_POS  330
#define ANGLER_HORIZONTAL_POS 1165
#define ANGLER_TOP_POS 3866

#define ANGLER_TOP_LIM_POS (ANGLER_TOP_POS-1000)

#define ANGLER_AXEL_POS (ANGLER_TOP_POS-2000)

#define ANGLER_GROUND_PICKUP_POS 900
#define ANGLER_BELOW_CAP_PICKUP_POS 680
#define ANGLER_CAP_PICKUP_POS 1570
#define ANGLER_LOW_PF_PICKUP_POS 1470

#define ANGLER_PICKUP_CAP_POS 1530

#define ANGLER_CAP_FLIP_POS 820

int gAnglerBackTopFlag = 1590; //1430; //1390; //1490
int gAnglerBackMidFlag = 1340; //1235; //1175; //1270

int gAnglerFrontPFTopFlag = 1885;//1790;//1730;
int gAnglerFrontPFMidFlag = 1460;//1310;

int gAnglerMidPFTopFlag = 1570;//1730;
int gAnglerMidPFMidFlag = 1250;//1310;

//Positions shooting from back of front platform tile
int gAnglerBackPFTopFlag = 1630;//1410;
int gAnglerBackPFMidFlag = 1370;//1160;

int gAnglerPower = 0;
void setAngler(word val)
{
	setMotor(angler, val);
}

typedef enum _tAnglerState
{
	anglerIdle,
	anglerMove,
	anglerHold,
	anglerManual
} tAnglerState;

tAnglerState gAnglerState = anglerIdle;
tAnglerState gAnglerStateLst = gAnglerState;
unsigned long gAnglerStateTime = nPgmTime;
int gAnglerStateSen = SensorValue[anglerPoti];

int gAnglerTarget = ANGLER_BOTTOM_POS;
int gAnglerGoodCount = 0;
int gAnglerAcceptableRange = 25;

void setAnglerState (tAnglerState state, int acceptableRange = 25)
{
	tHog();
	if (state != gAnglerState)
	{
		gAnglerStateLst = gAnglerState;
		gAnglerState = state;

		gAnglerAcceptableRange = abs(acceptableRange);

		gAnglerStateTime = nPgmTime;
		gAnglerStateSen = SensorValue[anglerPoti];
		#if defined(ANGLER_STATE_LOGS)

			writeDebugStream("%d Angler State Set %d ", nPgmTime, gAnglerState);
			switch(gAnglerState)
			{
			case anglerIdle: writeDebugStream("anglerIdle"); break;
			case anglerMove: writeDebugStream("anglerMove"); break;
			case anglerHold: writeDebugStream("anglerHold"); break;
			case anglerManual: writeDebugStream("anglerManual"); break;

			default: writeDebugStream("UNKNOWN STATE"); break;
			}
			writeDebugStreamLine(". Targ:%d, Sen:%d, Time:%d, GoodCount:%d. AccRange:%d", gAnglerTarget, gAnglerStateSen, gAnglerStateTime, gAnglerGoodCount, gAnglerAcceptableRange);
		#endif
	}
	tRelease();
}

task anglerStateSet()
{
	unsigned long time = nPgmTime;
	unsigned long timeLst = 0;
	unsigned long deltaTime = 0;
	unsigned long sen = 0;
	unsigned long senLst = 0;
	unsigned long deltaSen = 0;

	float kP = 0.095;//0.09;
	float kI = 0.03;//0.048;//0.016;
	float iVal, pVal;

	setAnglerState(anglerIdle);
	writeDebugStreamLine("%d Start Angler Machine. S:%d", nPgmTime, gAnglerState);

	while (true)
	{
		switch (gAnglerState)
		{
		case anglerIdle:
			{
				setAngler(0);
				break;
			}
		case anglerMove:
			{
				gAnglerGoodCount = 0;
				if (SensorValue[anglerPoti] < gAnglerTarget)
				{
					float kP = 0.3;
					//int targ = gAnglerTarget - ((abs(gAnglerAcceptableRange)<30)? 300 : 200);
					int targ = gAnglerTarget - 300;
					unsigned long startMoveTime = nPgmTime;
					while(SensorValue[anglerPoti] < targ && (nPgmTime-startMoveTime) < 1500)
					{
						tHog();
						int error = gAnglerTarget - SensorValue[anglerPoti];
						float power = error * kP;
						if (abs(SensorValue[anglerPoti]-ANGLER_HORIZONTAL_POS) < 250) power+=6;
						setAngler(power);
						tRelease();
						sleep(10);
					}
					setAngler(-15);
					unsigned long startBreakTime = nPgmTime;
					float vel = 10;
					do
					{
						sen = SensorValue[anglerPoti];
						time = nPgmTime;

						vel = (float)(sen-senLst)/(float)(time-timeLst);

						//LOG_ANGLER(("%d Angler Break. Pos:%d, Vel:%f", nPgmTime, sen, vel));
						senLst = sen;
						timeLst = time;
						sleep(10);
					} while ((vel > 2.7 && (nPgmTime-startBreakTime) < 100) || (nPgmTime-startBreakTime) < 20);
					setAngler(0);
				}
				else
				{
					float kP = 0.1;
					//int targ = gAnglerTarget + ((abs(gAnglerAcceptableRange)<30)? 300 : 200);
					int targ = gAnglerTarget;// + 300;
					unsigned long startMoveTime = nPgmTime;
					while(SensorValue[anglerPoti] > (targ+100) && (nPgmTime-startMoveTime) < 1500)
					{
						tHog();
						int error = gAnglerTarget - SensorValue[anglerPoti];
						float power = error * kP;
						//if (abs(SensorValue[anglerPoti]-ANGLER_HORIZONTAL_POS) < 250) power+=6;
						setAngler(power);
						tRelease();
						sleep(10);
					}
					setAngler(17);
					unsigned long startBreakTime = nPgmTime;
					float vel = 10;
					do
					{
						sen = SensorValue[anglerPoti];
						time = nPgmTime;

						vel = (float)(sen-senLst)/(float)(time-timeLst);

						//LOG_ANGLER(("%d Angler Break. Pos:%d, Vel:%f", nPgmTime, sen, vel));
						senLst = sen;
						timeLst = time;
						sleep(10);
					} while ((vel < -2.7 && (nPgmTime-startBreakTime) < 100) || (nPgmTime-startBreakTime) < 20);
					setAngler(0);
				}
				setAnglerState(anglerHold, gAnglerAcceptableRange);
				break;
			}
		case anglerHold:
			{
				tHog();
				if (gAnglerTarget > ANGLER_AXEL_POS && SensorValue[shooterEnc] > (SHOOTER_RELOAD_POS-10)) gAnglerTarget = ANGLER_AXEL_POS;
				time = nPgmTime;
				sen = SensorValue[anglerPoti];

				int error = gAnglerTarget - SensorValue[anglerPoti];
				pVal = error * kP;

				unsigned long deltaTime = time-timeLst;
				deltaSen = sen - senLst;
				if (deltaTime <= 0 || abs(deltaSen) > 10 || abs(error) < (abs(gAnglerAcceptableRange)-15))// || gAnglerStateLst == anglerManual)
				{
					iVal = 0;
				}
				else iVal += ( (float)error / (float)(deltaTime) ) * kI;

				if (error > 0 && deltaSen < 5  && abs(error) > gAnglerAcceptableRange) //If we are stalled below our target, i must be grater than 8
				{
					if (SensorValue[anglerPoti] < 1350 && iVal < 8) iVal = 8;
					else if (SensorValue[anglerPoti] > 1350 && iVal < 15) iVal = 15;
				}

				if (abs(deltaSen) < 5 && abs(error) < gAnglerAcceptableRange)// && abs(gAnglerGoodCount) < 25)
				{
					gAnglerGoodCount++;
					SensorValue[LED1] = 300;
					//playTone(300, 1);
					//LOG_ANGLER(("  %d Angler Stopped at %d. Inc gAnglerGoodCount to %d. Err:%d", nPgmTime, sen, gAnglerGoodCount, (gAnglerTarget-sen)));
				}
				else
				{
					gAnglerGoodCount = 0;
					SensorValue[LED1] = 0;
				}

				int power = pVal + iVal;// + 5;
				if (SensorValue[anglerPoti] < gAnglerTarget && abs(SensorValue[anglerPoti]-ANGLER_HORIZONTAL_POS) < 250) power+=6;

				setAngler(power);

				//if(gAnglerStateLst == anglerMove)
				unsigned long tElpsd = (nPgmTime-gAnglerStateTime);

				//LOG(anglerAlg)("%d Sen:%d, Err: %d, pVal:%f, iVal:%f, pow: %f, dT:%d, dS:%d", nPgmTime, SensorValue[anglerPoti], error, pVal, iVal, power, deltaTime, deltaSen);

				//if (gAnglerGoodCount == 5) LOG_ANGLER(("   %d Done angler hold to %d in %d ms. vel:%f. Sen:%d", nPgmTime, gAnglerTarget, (nPgmTime-gAnglerStateTime)), (deltaSen/deltaTime), SensorValue[anglerPoti]);
				senLst = sen;
				timeLst = time;

				//datalogDataGroupStart();
				//datalogAddValue(0, SensorValue[anglerPoti]);
				//datalogAddValue(1, (pVal*10.0));
				//datalogAddValue(2, (iVal*10.0));
				//datalogAddValue(3, gAnglerPower);
				//datalogAddValue(4, SensorValue[shooterEnc]);
				//datalogAddValue(5, SensorValue[ballDetector]);
				//datalogDataGroupEnd();

				tRelease();
				break;
			}
		case anglerManual:
			{
				if (abs(vexRT[JOY_ANGLER]) > ANGLER_DZ)
				{
					if (vexRT[JOY_ANGLER] > 0 && SensorValue[anglerPoti] < (ANGLER_TOP_LIM_POS - 100))
					{
						if (SensorValue[anglerPoti] > ANGLER_AXEL_POS && SensorValue[shooterEnc] > (SHOOTER_RELOAD_POS-10)) goto AnglerHoldTrigger;
						setAngler(vexRT[JOY_ANGLER]);
					}
					else if (vexRT[JOY_ANGLER] < 0 && SensorValue[anglerPoti] > (ANGLER_BOTTOM_POS + 100)) setAngler(vexRT[JOY_ANGLER]);
					else goto AnglerHoldTrigger;
				}
				else
				{
				AnglerHoldTrigger:
					setAngler(0);
					sleep(200);
					gAnglerTarget = SensorValue[anglerPoti];
					//setAnglerState(anglerIdle);
					setAnglerState(anglerHold, 100);
				}
				break;
			}
		}

		if (anglerDatalog)
		{
			tHog();
			datalogDataGroupStart();
			datalogAddValue(0, SensorValue[anglerPoti]);
			datalogAddValue(1, (pVal*10.0));
			datalogAddValue(2, (iVal*10.0));
			datalogAddValue(3, gMotor[angler].powerCur);
			datalogAddValue(4, vexRT[JOY_ANGLER]);
			//datalogAddValue(4, SensorValue[shooterEnc]);
			//datalogAddValue(5, SensorValue[ballDetector]);
			datalogDataGroupEnd();
			tRelease();
		}

		sleep(10);
	}
}

/* Shooter Controls */
#define BD_UNPLUGGED (SensorValue[ballDetector] >= 244 && SensorValue[ballDetector] <= 252)
#define BALL_DETECTED (SensorValue[ballDetector] < 2000)// && (!BD_UNPLUGGED))

typedef enum _tShooterState
{
	shooterIdle,
	shooterBreak,
	shooterReload,
	shooterHold,
	shooterShoot,
	shooterReset
} tShooterState;

void setShooter(word val)
{
	setMotor(shooter, val);
	setMotor(shooterY, val);
}
tShooterState gShooterState = shooterIdle;
tShooterState gShooterStateLst = gShooterState;
tShooterState gShooterStateLstLst = gShooterStateLst;
unsigned long gShooterStateTime; //Stores the time the shooter state is changed
unsigned long gShooterBreakStateTime = 0;
int gShooterStateSen;
bool gShooterKilled = false;

//bool gShooterTimedOut = false;

void setShooterState (tShooterState state)
{
	tHog();
	if (state != gShooterState)
	{
		unsigned long deltaTime = (nPgmTime - gShooterStateTime);

		gShooterStateLstLst = gShooterStateLst;
		gShooterStateLst = gShooterState;
		gShooterState = state;

		gShooterStateTime = nPgmTime;
		gShooterStateSen = SensorValue[shooterEnc];
		writeDebugStream("%d Shooter State Set %d ", nPgmTime, gShooterState);
		switch(gShooterState)
		{
		case shooterIdle: writeDebugStream("shooterIdle"); break;
		case shooterBreak: writeDebugStream("shooterBreak"); break;
		case shooterReload: writeDebugStream("shooterReload"); break;
		case shooterHold: writeDebugStream("shooterHold"); break;
		case shooterShoot: writeDebugStream("shooterShoot"); break;
		case shooterReset: writeDebugStream("shooterReset"); break;
		default: writeDebugStream("UNKNOWN STATE"); break;
		}

		writeDebugStreamLine(", dTimeLst:%dms, Count:%d, Sen:%d, Targ:%d, NextTarg:%d", deltaTime, gShooterShotCount, gShooterStateSen, SHOOTER_SHOOT_POS, SHOOTER_NEXT_SHOOT_POS, gShooterStateTime);
	}
	tRelease();
}

task shooterStateSet()
{
	setShooterState(shooterIdle);
	writeDebugStreamLine("%d Start Shooter Machine. S:%d", nPgmTime, gShooterState);

	float shooterBreakOffset = 12;

	while (true)
	{
		switch (gShooterState)
		{
		case shooterIdle:
			{
				setShooter(0);
				break;
			}
		case shooterBreak:
			{
				tHog();
				gShooterBreakStateTime = nPgmTime;

				setShooter(-90);
				unsigned long timerStart = nPgmTime;
				tRelease();
				while( (nPgmTime-timerStart) < 90 ) sleep(10);
				setShooter(0);
				//playTone(300, 50);

				setShooterState(shooterReload);
				break;
			}
		case shooterReload:
			{
				if (SensorValue[anglerPoti] < ANGLER_AXEL_POS)
				{
					setShooter(127);
					int target = SHOOTER_RELOAD_POS;

					while(SensorValue[shooterEnc] < target)
					{
						sleep(10);
					}
					setShooter(0);

					LOG_SHOOTER(("%d Reloaded to %d. Targ: %d", nPgmTime, SensorValue[shooterEnc], target))

					setShooterState(shooterHold);
				}
				else
				{
					LOG_SHOOTER(("%d ShtrReload->idle: Anglr @ axelPos", nPgmTime))
					setShooterState(shooterIdle);
				}
				break;
			}
		case shooterHold:
			{
				setShooter(SHOOTER_RELOAD_HOLD);
				break;
			}
		case shooterShoot:
			{
				unsigned long shotStartTime = nPgmTime;
				gShooterShotCount++;
				int target = SHOOTER_SHOOT_POS;
				setShooter(127);
				//LOG_SHOOTER(("%d Start shot %d: Time: %d Pos:%d ", nPgmTime, gShooterShotCount, nPgmTime-shotStartTime, SensorValue[shooterEnc]))

				bool shotTargReached = ( SensorValue[shooterEnc] > (target-shooterBreakOffset) );

				while(!shotTargReached && (SensorValue[shooterEnc] < (target-80) || SensorValue[shooterEnc] > (target-35) || BALL_DETECTED))
				{
					tHog();
					shotTargReached = ( SensorValue[shooterEnc] > (target-shooterBreakOffset) );

					unsigned long timeElpsd = nPgmTime-shotStartTime;
					//LOG_SHOOTER(("  %d Shooter moving to targ. Count%d. Targ:%d. Cur:%d", nPgmTime, gShooterShotCount, target, SensorValue[shooterEnc]))
					tRelease();
					sleep(10);
				}
				if (!shotTargReached)
				{
					tHog();
					LOG_SHOOTER(("%d Ball gone(%d), Time: %d Pos:%d, Targ:%d ", nPgmTime, SensorValue[ballDetector], nPgmTime-shotStartTime, SensorValue[shooterEnc], target))
					gShooterShotCount--;
					//playTone(300, 50);

					setShooterState(shooterBreak);
					tRelease();
				}
				else
				{
					LOG_SHOOTER(("%d ShotBrake: TElpsd:%d Pos:%d ", nPgmTime, nPgmTime-shotStartTime, SensorValue[shooterEnc]))
					setShooter(-26);
					unsigned long startBreakTime = nPgmTime;

					bool ballThere = true;
					while ((nPgmTime-startBreakTime) < 80)
					{
						if (ballThere && !BALL_DETECTED)
						{
							ballThere = false;
							LOG_SHOOTER(("  > %d BALL HIT. Angler pos:%d pow:%d. Err:%d", nPgmTime, SensorValue[anglerPoti], gMotor[angler].powerCur, (gAnglerTarget-SensorValue[anglerPoti])))
						}
						sleep(10);
					}
					setShooter(0);

					setShooterState(shooterReload);
				}
				break;
			}
		case shooterReset:
			{
				LOG_SHOOTER(("%d Shtr rest(rset). ShtCnt:%d. Pos:%d", nPgmTime, gShooterShotCount, SensorValue[shooterEnc]))
				setShooter(0);
				sleep(700);

				//LOG_SHOOTER(("%d Rst shtr at -14", nPgmTime))
				setShooter(-14);
				float pos = SensorValue[shooterEnc];
				float lstPos = 10;
				float vel = -1;
				float velLst = -1;
				unsigned long time = nPgmTime;
				unsigned long lstTime = 0;
				sleep(300);
				do
				{
					pos = SensorValue[shooterEnc];
					time = nPgmTime;

					velLst = vel;

					vel = (float)(pos-lstPos);///(float)(time-lstTime);
					LOG_SHOOTER(("%d RSTPow:%d, Pos:%d, PosLst:%d, Vel: %f, VelLst:%d", nPgmTime, gMotor[shooter].powerCur, pos, lstPos, vel, velLst))

					lstPos = pos;
					lstTime = time;
					sleep(50);
				} while(vel < -1 || velLst < -1);
				LOG_SHOOTER(("%d Rst Shtr frm %d. Vel:%d. VelLst:%d", nPgmTime, SensorValue[shooterEnc], vel, velLst))
				SensorValue[shooterEnc] = 0;
				gShooterShotCount = 0;
				sleep(50);

				//if (SensorValue[anglerPoti] < ANGLER_AXEL_POS) setShooterState(shooterReload);
				setShooterState(shooterIdle);
				//setShooterState(shooterReload);
				break;
			}
		}
		sleep(10);
	}
}

void shooterSafetySet(tShooterState state)
{
	unsigned long stateElpsdTime = (nPgmTime-gShooterStateTime);
	int senChange = SensorValue[shooterEnc]-gShooterStateSen;
	writeDebugStreamLine(">>	  %d Shootr State %d Sfty. TO: %d SenChange: %d", nPgmTime, gShooterState, stateElpsdTime, senChange);
	stopTask(shooterStateSet);
	startTask(shooterStateSet);
	setShooterState(state);
}

void killShooter()
{
	if (!gShooterKilled)
	{
		//Kill shooter
		unsigned long stateElpsdTime = (nPgmTime-gShooterStateTime);
		int senChange = SensorValue[shooterEnc]-gShooterStateSen;
		gShooterKilled = true;
		stopTask(shooterStateSet);
		setShooter(0);
		writeDebugStreamLine("	>>>	 %d KILL SHOOTER! state:%d Safety TO: %d SenChange: %d, Sen:%d", nPgmTime, gShooterState, stateElpsdTime, senChange, SensorValue[shooterEnc]);
		setShooterState(shooterIdle);
		////Wait for shooter to come to stop
		//int sen, senLst, senDelta;
		//do
		//{
		//	sen = SensorValue[shooterEnc];
		//	senDelta = sen - senLst;
		//	writeDebugStream("%d Waiting for shooter to come to stop. Pos:%d. LstPos:%d, DeltaPos:%d", nPgmTime, sen, senLst, senDelta);
		//	senLst = sen;
		//	sleep(300);
		//}while(abs(senDelta) > 1);
		//sleep(1000);

		////Reset shooter
		//startTask(shooterStateSet);
		//setShooterState(shooterReset);

	}
}

void shooterSafetyCheck()
{
	tHog();
	if (!gShooterKilled)
	{
		unsigned long stateElpsdTime = (nPgmTime-gShooterStateTime);
		int senChange = SensorValue[shooterEnc]-gShooterStateSen;

		if (gShooterState == shooterReset)
		{
			//TODO: REVERT THIS SAFETY BACK TO COMMENTED OUT LINE
			if (stateElpsdTime > 10000) shooterSafetySet(shooterIdle);
			//if (stateElpsdTime > 500) shooterSafetySet(shooterIdle);
			//else if (stateElpsdTime > 250 && senChange > 10) killShooter();
		}
		else if (gShooterState == shooterReload)
		{
			if (stateElpsdTime > 700)
			{
				killShooter();
				setShooter(-90);
				sleep(90);
				setShooter(0);
			}
			else if (stateElpsdTime > 150 && senChange < 10 && nPgmTime > (gShooterBreakStateTime+700)) killShooter();
		}
		else if (gShooterState == shooterShoot)
		{
			if (stateElpsdTime > 1200)
			{
				killShooter();//shooterSafetySet(shooterBreak);
				setShooter(-90);
				sleep(90);
				setShooter(0);
			}
			else if (stateElpsdTime > 150 && senChange < 10 && nPgmTime > (gShooterBreakStateTime+700)) killShooter();
				//&& (gShooterStateLst != shooterBreak && gShooterStateLstLst != shooterBreak)) killShooter();
		}
	}
	tRelease();
}

void anglerMoveToPos(int pos, int acceptableRange)
{
	acceptableRange = abs(acceptableRange);

	gAnglerTarget = pos;
	gAnglerGoodCount = 0;
	setAnglerState(anglerMove, acceptableRange);

}

void anglerReachedAlert(int targ)
{
	int fStart, fEnd;
	if (SensorValue[anglerPoti] < targ) //Descending tones if below targ
	{
		fStart = 500; fEnd = 100;
	} else if (SensorValue[anglerPoti] > targ) //Ascending tones if above targ
	{
		fStart = 100; fEnd = 500;
	}
	if (SensorValue[anglerPoti] != targ)
	{
		playTone(fStart, 20);
		playTone(fEnd, 20);
	}

	if (abs(SensorValue[anglerPoti]-targ) > 30) playTone(fStart, 15); //Play third tone if out of range
}

typedef struct _sNextShot
{
	bool backShot;
	bool btnReleased;
	int anglerPos;
	int yTarg;
} sNextShot;

void setNextShot(sNextShot& nextShot, TVexJoysticks btn)
{
	if (RISING(BTN_FLAG_LT))
	{
		nextShot.anglerPos = nextShot.backShot? gAnglerBackTopFlag : gAnglerFrontPFTopFlag;
		nextShot.yTarg = -35;
	}
	else if (RISING(BTN_FLAG_LM))
	{
		nextShot.anglerPos = nextShot.backShot? gAnglerBackMidFlag : gAnglerFrontPFMidFlag;
		nextShot.yTarg = -35;
	}
	else if (RISING(BTN_FLAG_RT))
	{
		nextShot.anglerPos = nextShot.backShot? gAnglerBackTopFlag : gAnglerFrontPFTopFlag;
		nextShot.yTarg = 63;
	}
	else if (RISING(BTN_FLAG_RM))
	{
		nextShot.anglerPos = nextShot.backShot? gAnglerBackMidFlag : gAnglerFrontPFMidFlag;
		nextShot.yTarg = 63;
	}
	else if (!gJoy[btn].cur) nextShot.btnReleased = true;
}

void angleShoot(int pos, int acceptableRange, bool waitForShot, int angleTime, TVexJoysticks btn, sNextShot& nextShot)
{
	unsigned long startTime = nPgmTime;
	int startShotCount = gShooterShotCount;

	setShooterState(shooterReload); //Make sure that the shooter is reloaded
	gAnglerTarget = pos;
	gAnglerGoodCount = 0;
	setAnglerState(anglerMove, acceptableRange);
	//Move shooter once it's in hold (protects from reload state overwriting our state-change-request)
	while (gShooterState != shooterHold)
	{
		setNextShot(nextShot, btn);
		sleep(10);
	}
	LOG_MACRO(("	>> %d Reload took:%dms.", nPgmTime, (nPgmTime-startTime)))
	if (waitForShot && abs(SensorValue[anglerPoti]) > acceptableRange)
	{
		//setSafetyTO(anglerSafety, "shot1", 8000);
		//WHILE(anglerSafety, (gAnglerGoodCount < kGoodCount))
		unsigned long waitTimeAbs, waitTimeRel;
		if(gShooterState == shooterHold && gShooterStateLst == shooterReload) waitTimeAbs = (angleTime-SHOOTER_SHOOT_LOADED_TIME);
		else waitTimeAbs = (angleTime-SHOOTER_SHOOT_UNLOADED_TIME);
		unsigned long curTime = nPgmTime;
		waitTimeRel = startTime + waitTimeAbs;
		LOG_MACRO((" >> %d waitTimeAbs = %d, waitTimeRel = %d", nPgmTime, waitTimeAbs, waitTimeRel))
		while(nPgmTime < waitTimeRel)
		{
			setNextShot(nextShot, btn);
			sleep(10);
		}
		LOG_MACRO(("	>> %d AnglerWait took %dms. Pos: %d", nPgmTime, (nPgmTime-startTime), SensorValue[anglerPoti]))
		//LOG_MACRO(("	>> %d Angle (FirstShot) took:%dms. Pos: %d", nPgmTime, (nPgmTime-startTime), SensorValue[anglerPoti]))
	}

	//Start taking shot
	setShooterState(shooterShoot);
	unsigned long shotTriggerTime = nPgmTime;

	while (gShooterState != shooterReload) //Start moving angler immediately after first shot applies breaking
	{
		setNextShot(nextShot, btn);
		sleep(10);
	}

	if ((gShooterShotCount-startShotCount) < 1)
	{
		LOG_MACRO(("	>> %d RETRY SHOT", nPgmTime))
		while (gShooterState != shooterHold)
		{
			setNextShot(nextShot, btn);
			sleep(10);
		}
		setShooterState(shooterShoot);
		shotTriggerTime = nPgmTime;
		while (gShooterState != shooterReload) //Start moving angler immediately after first shot applies breaking
		{
			setNextShot(nextShot, btn);
			sleep(10);
		}
	}
	LOG_MACRO(("	>> %d Sht+Angl t:%dms. Shot t:%dms", nPgmTime, (nPgmTime-startTime), (nPgmTime-shotTriggerTime)))
	setShooterState(shooterReload); //Make sure shooter is set to reload
																//(should not ever do anything b/c it should already be in reload state)
}

//ToDo: Add safeties to anglerShooter
void anglerShooter(int posA, int posB, int acceptableRange, bool waitForFirstShot = true, bool waitForSecShot = true, int angleTime, TVexJoysticks btn)
{
	acceptableRange = abs(acceptableRange);

	//Initialize next shot queue information
	sNextShot nextShot;
	nextShot.backShot = (posA == gAnglerBackPFTopFlag || posA == gAnglerBackPFMidFlag)? true : false;
	nextShot.btnReleased = false;
	nextShot.anglerPos = -1;
	nextShot.yTarg = -1;

	//Handle test mode
	if (gShootTuneMode)
	{
		acceptableRange = 15;
		angleTime = 2500;
		waitForFirstShot = true;
		waitForSecShot = true;
	}

	LOG_MACRO((" >%d AnglrShooter: FrstPos:%d. Wait?%d. ScndPos:%d. Wait?%d. CurAnglrPos:%d", nPgmTime, posA, waitForFirstShot, posB, waitForSecShot, SensorValue[anglerPoti]));
	unsigned long startTime = nPgmTime;

	//First shot
	LOG_MACRO((">>%d AnglShot1", nPgmTime))
	angleShoot(posA, acceptableRange, waitForFirstShot, angleTime, btn, nextShot);
	resetPositionFull(gPosition, (144-BACK_OFFSET), 14, -90);

	//Second Shot Turn
	if (nextShot.yTarg != -1)
	{
		turnToTargetAccurate(10, nextShot.yTarg, ch, 50, 50, 0);
	}

	//Second Shot Execution
	if ((!nextShot.btnReleased && gJoy[btn].cur) || (nextShot.anglerPos != -1))
	{
		LOG_MACRO((">>%d AnglShot2", nPgmTime))

		if (!nextShot.btnReleased && gJoy[btn].cur)
			angleShoot(posB, acceptableRange, waitForSecShot, angleTime, btn, nextShot);
		else if (nextShot.anglerPos != -1)
			angleShoot(nextShot.anglerPos, acceptableRange, waitForSecShot, angleTime, btn, nextShot);

		LOG_MACRO((" >> %d Anglr(sht): grnd p_u pos", nPgmTime))
		anglerMoveToPos(ANGLER_GROUND_PICKUP_POS, 150);
	}


	LOG_MACRO(("	>> %d Done pntSht in %dms. Anglr:%d. Shooter:%d", nPgmTime, (nPgmTime-startTime), SensorValue[anglerPoti], SensorValue[shooterEnc]))

	if(SensorValue[anglerPoti] > ANGLER_AXEL_POS)
	{
		while (gAnglerGoodCount < 2) sleep(10);
		setShooterState(shooterReload);
	}
}

int anglerShooterPosA, anglerShooterPosB, anglerShooterAcceptableRange, anglerAngleTime;
bool anglerShooterWaitForFirstShot, anglerShooterWaitForSecShot;
TVexJoysticks anglerShooterBtn;
task anglerShooterTask()
{
	gAnglerShooterTaskRunning = true;
	gAnglerShooterTaskTime = nPgmTime;
	anglerShooter(anglerShooterPosA, anglerShooterPosB, anglerShooterAcceptableRange, anglerShooterWaitForFirstShot, anglerShooterWaitForSecShot, anglerAngleTime, anglerShooterBtn);
	gAnglerShooterTaskTime = 0;
	gAnglerShooterTaskRunning = false;
	return;
}
#define ANGLER_SHOOTER_TASK(posA, posB, acceptableRange, waitForFirstShot, waitForSecShot, angleTime, btn, reversePos) \
anglerShooterPosA = posA; anglerShooterPosB = posB; anglerShooterAcceptableRange = acceptableRange; anglerAngleTime = angleTime; \
anglerShooterWaitForFirstShot = waitForFirstShot; anglerShooterWaitForSecShot = waitForSecShot; \
anglerShooterBtn = btn; \
startTask(anglerShooterTask)

#define ANGLER_SHOOTER_TASK_KILL \
	gAnglerShooterTaskTime = 0; \
	gAnglerShooterTaskRunning = false; \
	stopTask(anglerShooterTask)

//Declarations for ball log
bool gBallThere = false;
bool gBallThereLst = gBallThere;

float gAnglerSen = SensorValue[anglerPoti];
float gAnglerSenLst = gAnglerSen;
unsigned long gBallTime = nPgmTime;
unsigned long gBallTimeLst = gBallTime;
//float anglerVel;

void ballTrackLog()
{
	tHog();

	gBallThere = BALL_DETECTED;
	gAnglerSen = SensorValue[anglerPoti];
	gBallTime = nPgmTime;

	float anglerVel;
	if ((gBallTime-gBallTimeLst) > 0)
		anglerVel = ( (float)(gAnglerSen-gAnglerSenLst) / (float)(gBallTime-gBallTimeLst) );
	else anglerVel = 0;

	if (gBallThere && !gBallThereLst) writeDebugStream("	> %d Ball Detected", nPgmTime);
	else if (!gBallThere && gBallThereLst) writeDebugStream("	> %d Ball Off", nPgmTime);
	if((gBallThere && !gBallThereLst) || (!gBallThere && gBallThereLst))
		writeDebugStreamLine(" (%d). Shooter:%d Angler:%d (err:%d). Vel:%f", SensorValue[ballDetector], SensorValue[shooterEnc], SensorValue[anglerPoti], (gAnglerTarget-SensorValue[anglerPoti]), anglerVel);

	gBallThereLst = gBallThere;
	gAnglerSenLst = gAnglerSen;
	gBallTimeLst = gBallTime;

	tRelease();
}

task monitorVals()
{
	while(true)
	{
		tHog();
		shooterSafetyCheck();
		ballTrackLog();

		datalogDataGroupStart();
		datalogAddValue(0, SensorValue[anglerPoti]);
		//datalogAddValue(1, (pVal*10.0));
		//datalogAddValue(2, (iVal*10.0));
		datalogAddValue(3, gMotor[angler].powerCur);
		datalogAddValue(4, SensorValue[shooterEnc]);
		datalogAddValue(5, SensorValue[ballDetector]);
		datalogDataGroupEnd();

		tRelease();

		sleep(10);
	}
}

/* Modes */
task handleLCD(); //handleLCD task predeclaration

void startTasks(bool driveTaskStart)
{
	tHog();

	setupMotors();

	if (driveTaskStart) startTask(driveStateSet);

	startTask(shooterStateSet);
	startTask(intakeStateSet);
	startTask(decapperStateSet);
	startTask(anglerStateSet);

	startTask(monitorVals);

	startTask(handleLCD);

	tRelease();
}

void stopTasks()
{
	tHog();
	stopTask(driveStateSet);
	stopTask(shooterStateSet);
	stopTask(intakeStateSet);
	stopTask(decapperStateSet);
	stopTask(anglerStateSet);

	stopTask(monitorVals);

	stopTask(handleLCD);
	tRelease();
}

void startup()
{
	tHog();
	clearDebugStream();
	datalogClear();
	setupMotors();
	updateTurnLookup();
	//initSafeties();

	clearSounds();

	gBatteryLevel = nImmediateBatteryLevel;
	gBackupBatteryLevel = BackupBatteryLevel;
	writeDebugStreamLine("%d Startup Battery: %d", nPgmTime, gBatteryLevel);

	SensorValue[shooterEnc] = 0;

	//Tracking
	stopTask(trackPositionTask);
	resetPositionFull(gPosition, 0, 0, 0);
	startTask(trackPositionTask);

	startTasks(true);
	sleep(50);

	//Reset Shooter
	gShooterKilled = false;
	setShooterState(shooterReset);
	tRelease();
	sleep(50);
	while(gShooterState != shooterHold && gShooterState != shooterIdle) sleep(10);

	//Setup Joysticks & Buttons
	setupJoysticks();
	enableAllButtons();
}

void disabled()
{
	//updateSensorInputs();

	//selectAuto();
	//handleLcd();
}

#include "auto_runs.h"
tAlliance allianceForce = -1;//allianceRed;///-1;
tAuto autoForce = -1;//autoSkills;//-1;

#include "auto_runs.c"

task autonomous()
{
	writeDebugStreamLine("\n%d Start Autonomous", nPgmTime);
	//Initialize auto selection choices

	unsigned long autoStartTime = nPgmTime;

	startTasks(false);
	stopTask(driveStateSet);

	selectAuto(); //selects auto based on potentiometer and gAutoPreloadFlag variable
	writeDebugStream("%d Auto:%d", nPgmTime, gAuto);
	runAuto(); //runs auto depending on gAuto and gAlliance

	writeDebugStreamLine("%d AutoT:%d", nPgmTime, (nPgmTime-autoStartTime));
	stopTasks();
}

task usercontrol()
{
	writeDebugStreamLine("\n%d Start UserControl", nPgmTime);
	sCycleData cycle;
	initCycle(cycle, 10, "usercontrol");

	startTasks(true);

	//int lstShotCount = 0;
	unsigned long lstShotTimer = 0;

	sleep(10);
	setShooterState(shooterReload);

	//setDriveState(driveManual);
	while (true)
	{
		/* Drive Controls */
		gDriveThrottleRaw = vexRT[JOY_DRIVE_THROTTLE];
		gDriveTurnRaw = vexRT[JOY_DRIVE_TURN];
		if ( ((abs(gDriveTurnRaw) > DRIVE_TURN_DZ) || (abs(gDriveThrottleRaw) > DRIVE_THROTTLE_DZ)) && gDriveState != driveMoveTime) setDriveState(driveManual);

		/* Intake Controls */
		if (!gAnglerShooterTaskRunning)
			intakeControls();

		/* Decapper Controls */
		if (!gAnglerShooterTaskRunning)
			decapperControls();

		/* Shooter & Angler Controls */
		if (gAnglerShooterTaskRunning && gAnglerShooterTaskTime > 0 && nPgmTime > (gAnglerShooterTaskTime+6000))
		{
			ANGLER_SHOOTER_TASK_KILL;
			writeDebugStreamLine("	>>>> %d AnglerShooterTask TO. KILL", nPgmTime);
		}
		else if (gAnglerShooterTaskRunning && RISING(BTN_SHOOT))
		{
			ANGLER_SHOOTER_TASK_KILL;
			writeDebugStreamLine("> %d AnglerShooterTask Cancl <", nPgmTime);
		}
		else if (!gAnglerShooterTaskRunning && gShooterState != shooterReset)
		{
			if (RISING(BTN_SHOOT))
			{
				if (gJoy[BTN_SHIFT].cur)
				{
					tHog();
					stopTask(shooterStateSet);
					startTask(shooterStateSet);
					gShooterKilled = false;
					sleep(10);
					setShooterState(shooterReset);
					tRelease();
					//sleep(50);
					//while(gShooterState != shooterHold && gShooterState != shooterIdle) sleep(10);
				}
				else if (SensorValue[shooterEnc] < SHOOTER_RELOAD_POS)
				{
					setShooterState(shooterReload);
				}
				else if (SensorValue[shooterEnc] >= (SHOOTER_NEXT_SHOOT_POS-50))
				{
					writeDebugStreamLine(" > %d Sht cnt wrng. Rst <", nPgmTime);
					shooterSafetySet(shooterReset);
				}
				else if (BALL_DETECTED && SensorValue[anglerPoti] > ANGLER_GROUND_PICKUP_POS)
				{
					setShooterState(shooterShoot);
					lstShotTimer = nPgmTime;
				}
			}
			if (!gJoy[BTN_SHOOT].cur) lstShotTimer = 0;
			else if (gJoy[BTN_SHOOT].cur && gShooterState == shooterHold && (lstShotTimer != 0 && (nPgmTime-lstShotTimer) < 900))
			{
				setShooterState(shooterShoot);
				lstShotTimer = 0;
			}
			/* Fancy Shot Selection */
			if (RISING(BTN_SHOOT_BACK_TOP))
			{
				tHog();
				writeDebugStreamLine(" > %d Bck Shoot T <", nPgmTime);
				setDriveState(driveBackHold);
				ANGLER_SHOOTER_TASK(gAnglerBackTopFlag, gAnglerBackMidFlag, 25, true, true, MAX_ANGLE_TIME, BTN_SHOOT_BACK_TOP);
				tRelease();
			}
			else if (RISING(BTN_SHOOT_BACK_MID))
			{
				tHog();
				writeDebugStreamLine(" > %d Bck Shoot M <", nPgmTime);
				setDriveState(driveBackHold);
				ANGLER_SHOOTER_TASK(gAnglerBackMidFlag, gAnglerBackTopFlag, 25, true, true, MAX_ANGLE_TIME, BTN_SHOOT_BACK_MID);
				tRelease();
			}
			else if (RISING(BTN_SHOOT_FRONT_TOP))
			{
				tHog();
				writeDebugStreamLine(" > %d F_PF Shoot T <", nPgmTime);
				ANGLER_SHOOTER_TASK(gAnglerFrontPFTopFlag, gAnglerFrontPFMidFlag, 70, false, true, MAX_ANGLE_TIME_FRONT, BTN_SHOOT_FRONT_TOP);
				tRelease();
			}
			else if (RISING(BTN_SHOOT_FRONT_MID))
			{
				tHog();
				writeDebugStreamLine(" > %d F_PF Shoot M <", nPgmTime);
				ANGLER_SHOOTER_TASK(gAnglerFrontPFMidFlag, gAnglerFrontPFTopFlag, 70, false, true, MAX_ANGLE_TIME_FRONT, BTN_SHOOT_FRONT_MID);
				tRelease();
			}
			/* Angler Controls */
			else if (RISING(BTN_ANGLER_CAP_PICKUP))
			{
				if (gJoy[BTN_SHIFT].cur)
				{
					writeDebugStreamLine(" > %d Anglr: flip cap pos <", nPgmTime);
					anglerMoveToPos(ANGLER_CAP_FLIP_POS, 100);
					setIntakeState(intakeDown);
				}
				else
				{
					writeDebugStreamLine(" > %d Anglr: grnd p_u pos <", nPgmTime);
					anglerMoveToPos(ANGLER_GROUND_PICKUP_POS, 150);
				}
			}
			else if (RISING(BTN_ANGLER_CAP_PICKUP))
			{
				writeDebugStreamLine(" > %d Anglr: p_u cap pos <", nPgmTime);
				anglerMoveToPos(ANGLER_PICKUP_CAP_POS, 150);
			}
			else if (abs(vexRT[JOY_ANGLER]) > ANGLER_DZ)
			{
				setAnglerState(anglerManual);
			}
		}

		endCycle(cycle);
	}

	stopTasks();
}

/* LCD Controls */
#include "LCD.h"
#include "LCD.c"
