#pragma config(Sensor, in1,    ballDetector,   sensorLineFollower)
#pragma config(Sensor, in8,    anglerPoti,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  shooterEnc,     sensorQuadEncoder)
#pragma config(Motor,  port2,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           shooterA,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooterRevSplit, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           angler,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ANGLE_FLAT 800
#define ANGLE_MID 1400
#define ANGLE_TOP 1800
#define SHOOTER_RELOAD_VAL (360.0)
#define SHOOTER_RELOAD_HOLD 11
#define SHOOTER_RELOAD_POS 145
const int gPresetAngles[3] = {ANGLE_FLAT,ANGLE_MID,ANGLE_TOP};
int curPos = 0;
int shotCount = 0;
bool cancelled = false;
bool gReadytoAngle = false;
int target;
void setShooter(int shootSpeed)
{
	motor[shooterA]=motor[shooterRevSplit]=shootSpeed;
}
void reloadShooter()
{
	setShooter(127);
	int target = shotCount * SHOOTER_RELOAD_VAL;
	while(SensorValue[shooterEnc]<(target+SHOOTER_RELOAD_POS))
	{
		sleep(10);
	}
	setShooter(SHOOTER_RELOAD_HOLD);
}
task shooterTask()
{
	shotCount = 0;
	SensorValue[shooterEnc]=0;
	while(true)
	{
		cancelled = false;
		if(vexRT[Btn6U])
		{
			int target = shotCount * SHOOTER_RELOAD_VAL;
			if (SensorValue[shooterEnc] < (target+SHOOTER_RELOAD_POS-10)) //Should only get triggered when shooterShotCount == 0
			{
				reloadShooter();
			}

			while(SensorValue[ballDetector]>1000){sleep(10);}
			while(SensorValue[ballDetector]>=250 & SensorValue[ballDetector]<=252){sleep(10);}
			shotCount++;
			target = shotCount * SHOOTER_RELOAD_VAL;
			setShooter(127);
			while(SensorValue[shooterEnc]<target+SHOOTER_RELOAD_POS)
			{
				if(SensorValue[ballDetector]>1000)
				{
					shotCount--;
					writeDebugStream("Shot failed");
					setShooter(-90);
					sleep(100);
					setShooter(0);

					cancelled = true;
				}
			}
			//gReadytoAngle = true;
			setShooter(SHOOTER_RELOAD_HOLD);
		}
	}
}

task intakeAngler()
{
for (int i =0; i<3; i++)
{
	if(SensorValue[anglerPoti]<gPresetAngles[i])
	{
		curPos=i-1;
		writeDebugStreamLine("Assigned position of int curPos is %d", curPos);
		break;
	}
}
float percentFull = 0.85;
float percentDecel = 0.95;
int decelSpeed = 68;
target=gPresetAngles[curPos+1];

	while(SensorValue[anglerPoti]<(percentFull*target))
	{
		motor[angler] = 127
	}
	while(SensorValue[anglerPoti]<(percentDecel*target))
	{
		int error = target-SensorValue[anglerPoti];
		motor[angler] = error*0.3;
	}
	while(SensorValue[anglerPoti]<target)
	{
		motor[angler] = -20;
	}

	sleep(100);
	motor[angler] = 15;
	sleep(300);
	writeDebugStreamLine("Intake Podi Value: %d",SensorValue[anglerPoti]);
}
task main()
{
startTask(shooterTask);
startTask(intakeAngler);
while(true) sleep(10);
stopTask(shooterTask);
stopTask(intakeAngler);
}
