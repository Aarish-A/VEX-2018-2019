#pragma config(Sensor, in1,    autoPoti,       sensorPotentiometer)
#pragma config(Sensor, in2,    mobilePoti,     sensorPotentiometer)
#pragma config(Sensor, in3,    liftPoti,       sensorPotentiometer)
#pragma config(Sensor, in4,    armPoti,        sensorPotentiometer)
#pragma config(Sensor, in5,    limLift,         sensorAnalog)
#pragma config(Sensor, in6,    lsBarL,         sensorReflection)
#pragma config(Sensor, in7,    lsBarR,         sensorReflection)
#pragma config(Sensor, in8,    lsMobile,       sensorReflection)
#pragma config(Sensor, dgtl1,  trackL,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  trackR,         sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  trackB,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  sonarL,         sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  limArm,         sensorTouch)
#pragma config(Sensor, dgtl10, jmpSkills,      sensorDigitalIn)
#pragma config(Sensor, dgtl11, sonarR,         sensorSONAR_mm)
#pragma config(Motor,  port2,           liftR,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveL1,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           driveL2,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           mobile,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           driveR2,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           driveR1,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           liftL,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define DATALOG_BATTERY -1

#define CHECK_POTI_JUMPS 1
#define DRIVE_TURN (gJoy[JOY_TURN].cur - gJoy[JOY_TURN].deadzone * sgn(gJoy[JOY_TURN].cur))
// Year-independent libraries (headers)
#include "../src/task.h"
#include "motors.h"
#include "sensors.h"
#include "joysticks.h"
#include "cycle.h"
#include "utilities.h"
#include "auto.h"

// Year-independent libraries (source)
#include "task.c"
#include "motors.c"
#include "sensors.c"
#include "joysticks.c"
#include "cycle.c"
#include "utilities.c"

#include "state.h"
#include "func_to_state.h"
//#include "state_test.h"

/* Example of how to use state.h and func_to_state.h libraries */
CREATE_MACHINE_3(drive, trackL, Idle, Break, Manual, float, Vel, int, Power)

PREP_FUNC_STATE_VOID_4(void, foo, int, a, int, b, int, c, int, d);
PREP_FUNC_STATE_4(int, bar, int, a, int, b, int, c, int, d);
ADD_FUNCS_TO_MACHINE_5(drive, foo, bar, b, c, d);

void foo(int a, int b, int c, int d)
{
	LOG(drive)("%d Start foo", npgmtime);
	WHILE(drive, npgmtime < a)
	{
		sleep(10);
	}
	LOG(drive)("%d time passed - exit foo", nPgmTime);
}
int bar(int a, int b, int c, int d)
{
	LOG(drive)("%d Start bar", npgmtime);
	return a;
}

task driveSet()
{
	driveLogs = true;
	while (true)
	{
		switch(driveState)
		{
			case driveIdle: //state 0
				driveBlocked = false;
				break;
			case driveBreak: //state 1
				driveBlocked = false;
				break;
			case driveManual: //state 2
				driveBlocked =  false;
				break;

			ADD_FUNC_TO_SWITCH_VOID_4(foo, drive, driveIdle, driveIdle); //state 3
			ADD_FUNC_TO_SWITCH_4(bar, drive, driveIdle, driveIdle); //state 4
		}
		sleep(10);
	}
}

void driveCode()
{
	writeDebugStreamLine("Log drive %d", driveLogs);
	ASSIGN_FUNC_STATE_4(foo, 3000, 2, 3, 4);
	driveStateChange(drivefoo, 1, 7000);
	//LOG(drive)("%d  Outside: blocked? %d -", driveBlocked);
	ASSIGN_FUNC_STATE_4(bar, 9, 2, 3, 4);
	driveStateChange(drivebar, 1,  2000);
	LOG(drive)("%d a = %d", npgmtime, barRet);
}

task main()
{
	startTask(driveSet);
	driveCode();
	while(true)
	{
		sleep(10);
	}

	stopTask(driveSet);
}
